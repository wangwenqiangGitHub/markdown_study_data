# 51单片机

## 基础知识

### 周期与频率

* 周期：完成一件时需要的时间

* 频率：单位时间内完成的次数

> 晶振频率：也就是一秒振多少次

* 时钟周期（振荡周期）：时钟脉冲（晶振）的倒数，晶振频率12MHZ，时钟周期为1/12us。
* 状态周期：51单片机中两个时钟周期为一个状态周期
* 机器周期：12个时钟周期
* 指令周期：执行一条指令所需要的时间

### 电容

大电容，通交流，隔直流。

如图，直流电开始接通时，电子流入左边极板，而右边极板上的电子流出。电容等效导线。充满电两端电压相等，电容等效开路。

![image-20210219090127958](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20210219090127958.png)



![image-20210204162651346](https://raw.githubusercontent.com/little-zhengjj/PicGo/master/img/image-20210204162651346.png)

* 复位电路（设电压为Vcc）

  * 上电：C3两端电压为0。此时充电，电容相当于导线，RST有高电平。一段时间后，C3电压与Vcc相同，充电结束，电阻两端电压为0，RST为低电平。
  * 按键：按下键时，RST置高，断开后RST为低。

  显然没有下面的电阻RST一直为低。

### P0口

P0口作为IO线输入状态时：1. 读引脚：2.读锁存器

P0口作为地址/数据复用口

P0口作为IO输出时，只能输出低电平、高阻态，需要外接上拉电阻，使高阻态变为输出高电平。

![image-20210205113810373](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20210205113810373.png)


1.P0作为地址数据总线时，V1和V2是一起工作的,构成推挽结构。高电平时，V1打开，V2截止;低电平时，V1截止，V2打开。这种情况下不用外接上拉电阻。而且,当V1打开,V2截止,输出高电平的时候,因为内部电源直接通过V1输出到P0口线上,因此驱动能力(电流)可以很大,这就是为什么教科书上说可以"驱动8个TTL负载"的原因。

2.P0作为一般端口时，V1就永远的截止，V2根据输出数据0导通和1截止，导通时拉地，当然是输出低电平;截止时，P0口就没有输出了，(注意,这种情况就是所谓的高阻浮空状态),如果加上外部上拉电阻，输出就变成了高电平1。

3.其他端口P1、P2、P3,在内部直接将P1口中的V1换成了上拉电阻,所以不用外接，但内部上拉电阻太大，电流太小，有时因为电流不够，也会再并一个上拉电阻。



![图片](https://mmbiz.qpic.cn/mmbiz/XZMicpgcYibXH6HtZ51ojicp4pyFbmVlrVra7xz8VjqNiaLl9f8LKSYwRVrevZfjXAmbVVsdiclDSMhlZvwo9HPJoPg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



⒋.在某个时刻,P0口上输出的是作为总线的地址数据信号还是作为普通I/O口的电平信号,是依靠多路开关MUX来切换的.而MUX的切换,又是根据单片机指令来区分的.当指令为外部存储器/IO口读/写时,比如 MOVX A,@DPTR ,MUX是切换到地址/数据总线上;而当普通MOV传送指令操作P0口时,MUX是切换到内部总线上的。

**PS:**

> 因为端口1、2、3有固定的内部上拉,所以有时候他们被称为"准双向"口.
>
> 端口0, 从另外一方面来说,就被 认为是"真正的"双向,因为当它被设置为输入的时候是浮空(高阻态)的.

⒌. p0(i/o),p1,p2,p3口用于输入时，需要写1使IO下拉的MOS管截止，以免MOS管导通将输入拉底为0，当一直用于输入时不用置1(先使用该IO输出，该IO锁存器里可能是0，再用该IO输入则会使MOS管导通)，将IO写1后，该IO锁存器不会变了，所以再一直用于输入不用置1。p0用于地址数据线时输入不用写1，因为MUX没和锁存器相连。

## 三极管

### 三极管做开关管

![img](http://c.51hei.com/a/old/up/0/412291592724874.jpg)

当Q1处于临界饱和时，流经R1的电流为 Ic=VCC/R1，若Q1的直流增益为β（β有直流增益和交流增益之分，不同的管子差很大），则流经R2的电流为 Ib=Ic/β=（Vin-Vbe）/R2，Vbe为基极与射极间的管压降，对硅管来说约为0.6V，对锗管来说，约为0.3V，此时的Vin=Ib*R2+Vbe。

若要令Q1处于深度饱和状态（即开关闭合状态），Vin应大于临界饱和值，即Vin>Ib*R2+Vbe，Vin=Vbe+（Vcc*R2）/（β*R1）。

若要令Q1处于截止状态（即开关打开状态），只需令Vin<Vbe即可，说简单点就是直接令Vin=0。

 

[![img](https://i.loli.net/2021/02/15/RHCMXyfA3aL49Qs.jpg)](http://c.51hei.com/a/old/up/0/412291592756057.jpg)

此外，三极管还可实现反相器的功能。当PWM1为高时，Q1导通，PWM2为低；当PWM1为低时，Q1截止，PWM2为高。

当驱动H桥时，只需产生一路PWM信号，再令三极管实现反相，便可得到两路占空比互补的信号。



## 流水灯

```c
#include <reg52.h>
#include <intrins.h>

typedef unsigned char uchar;
typedef unsigned int uint;

void Delayms(uint a);		//@11.0592MHz

int main(void)
{
	uchar temp = 0xfe; //初始值
	while(1)
	{
		P1 = temp;
		temp = _crol_(temp, 1);//循环左移
		Delayms(1000);
	}	
	return 0;
}
/************************************************
*												
*	延时程序：晶振频率11.0592MHZ，大约延时ams 	   
*												
*************************************************/
void Delayms(uint a)
{
	while(a--)
	{
		uchar i = 120;
		for (; i > 0; i--)
			;
	}
}

```

在原理图中可以看出，流水灯的控制口在P1。

![image-20210103132709236](https://raw.githubusercontent.com/little-zhengjj/PicGo/master/img/image-20210103132709236.png)

### 发光二极管

![image-20201026220127855](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201026220127855.png)

VCC是电源，可以理解为正5v，发光二极管流过3mA电流就可以亮。

二极管两端电压大概是1.7v，那就还剩3.3v的压降，要想有3mA的电流，就需要1k的电阻。

## 数码管

头文件：`head.h`

```c
#ifndef _HEAD_H
#define _HEAD_H

#include <reg52.h>

sbit sectionChoice = P2^6;//段选口
sbit placeChoice = P2^7;//位选口

typedef unsigned char uchar;
typedef unsigned int uint;

extern uchar table[16];
//延时程序 
void Delayms(uint a);
#endif
```

主函数; `数管码.c`

```c
#include <reg52.h>
#include "head.h"

//共阴极数码管显示16进制数
uchar table[16] = {
	0x3F, 0x06, 0x5B, 0x4F,
	0x66, 0x6D, 0x7D, 0x07,
	0x7F, 0x6F, 0x77, 0x7C,
	0x39, 0x5E, 0x79, 0x71,
};

int main(void)
{
	uchar j = 0;
	placeChoice = 1; //wela选端置1时，可以更改，位选锁存器
	P0 = 0xfe; //由P0传入数据
	placeChoice = 0;

	sectionChoice = 1;//段选打开
	P0 = table[j++]; //让数码管显示j位置数字，然后j + 1
	sectionChoice = 0;//段选关闭

	while(1)
	{
		Delayms(1000);
		sectionChoice = 1;//段选打开
		P0 = table[j++]; //让数码管显示j位置数字，然后j + 1
		sectionChoice = 0;//段选关闭

		if ( j == 16)//如果j为16，就重置
		{
			j = 0;
		}
	}
	return 0;
}

```

操作集：`operation.c`

```c
#include "head.h"

/************************************************
*												
*	延时程序：晶振频率11.0592MHZ，大约延时ams 	
*												
*************************************************/
void Delayms(uint a)
{
	while(a--)
	{
		uchar i = 120;
		for (; i > 0; i--)
			;
	}
}
```

### 数码管

![image-20210103135234270](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20210103135234270.png)

共阴极数管码，全部由P1口接一个锁存器控制。这个锁存器接在单片机的P2^7口，叫段选锁存器。

#### 锁存器

故名思意，他可以锁住数据。

**Latch Enable为高时，Q随D变化。**

**Latch Enable为低时，Q不随D变化。**

**另外，Output Enable为高时是高阻态。Q没有输出。**

​																						         	**==锁存器功能表==**

![img](https://raw.githubusercontent.com/little-zhengjj/PicGo/master/img/u%253D3859664761%252C3466474042%2526fm%253D26%2526gp%253D0.jpg)

这样，我们在用锁存器的时候就将Latch Enable置高，就可以改变其中的数据。不用时就将其置低，其中的数据不会变。

如下图有两个锁存器，一个接P2\^7，一个接P2\^6，一个控制位选（几个数码管亮），一个控制段选（数码管怎么亮）。要改变其中的数据，就将P2\^6或P2\^7置1，送入数据后，再置0，就可以一直是这个数据。

![image-20210103135548777](https://raw.githubusercontent.com/little-zhengjj/PicGo/master/img/image-20210103135548777.png)

## 中断定时数码管

头文件：`head.h`

```c
#include <reg52.h>

#ifndef HEAD_H
#define HEAD_H

sbit sectionChoice = P2^6; //段选 
sbit placeChoice = P2^7; //位选

typedef unsigned uchar;

extern uchar table[16];

//初始化程序
void initialize(uchar *p);

#endif 
```

主函数：`interrupttimer.c`(查询方式)

```c
#include <reg52.h>
#include "head.h"

//共阴极数码管显示16进制数
uchar table[16] = {
	0x3F, 0x06, 0x5B, 0x4F,
	0x66, 0x6D, 0x7D, 0x07,
	0x7F, 0x6F, 0x77, 0x7C,
	0x39, 0x5E, 0x79, 0x71,
};
uchar count;

int main(void)
{
	uchar number = 0;
	initialize();
	while(1)
	{
		while(!TF0);
		TF0 = 0;
		number++; //中断一次加1（50ms加1）

		//重置初始值
		TH0 = (65536 - 50000) / 256;
		TL0 = (65536 - 50000) % 256;
		if (number == 20) //到达1s
		{
			number = 0; //number清零

			//段选打开，放下一个数据
			sectionChoice = 1;
			P0 = table[count++];
			sectionChoice = 0;

			if (count == 16) //超过最大值（table只能表示16）
				count = 0; //count清零
		}
	}
	return 0;
}
```

主函数：`interrupttimer.c`(中断方式)

```c
#include <reg52.h>
#include "head.h"

//共阴极数码管显示16进制数
uchar table[16] = {
	0x3F, 0x06, 0x5B, 0x4F,
	0x66, 0x6D, 0x7D, 0x07,
	0x7F, 0x6F, 0x77, 0x7C,
	0x39, 0x5E, 0x79, 0x71,
};
static uchar number = 0;
void timer0(void) interrupt 1 using 1
{
	//重置初始值
	TH0 = (65536 - 50000) / 256;
	TL0 = (65536 - 50000) % 256;
	number++;	
}
int main(void)
{
	uchar count = 0;
	initialize(&count);
	while(1)
	{
		if (number == 20) //到达1s
		{
			number = 0; //number清零

			//段选打开，放下一个数据
			sectionChoice = 1;
			P0 = table[count++];
			sectionChoice = 0;

			if (count == 16) //超过最大值（table只能表示16）
				count = 0; //count清零
		}
	}
	return 0;
}
```

操作集：`operation.c`

```c
#include "head.h"
/********************************
*								
*	函数名：initialize			 
*	功能：初始化				    
*	参数：uchar count			  
*	返回值：增加1后的count		   
*								
*********************************/
void initialize(uchar *p)
{
	placeChoice = 1; //开位选
	P0 = 0xfe; //选位置
	placeChoice = 0; //关位选

	EA = 1;	//开总中断
	TMOD = 0x01; //设置定时器0为工作方式1
	ET0 = 1; //开定时器0中断
	
	TH0 = (65536 - 50000) / 256; //高八位初始值
	TL0 = (65536 - 50000) % 256; //低八位初始值
	
	sectionChoice = 1; //开段选
	P0 = table[(*p)++]; //显示table[0]处数据所表示的数字，count加1
	sectionChoice = 0; //关段选

	TR0 = 1; //启动定时器0
}
```

16位寄存器高低8位取值问题。

```c
	TH0 = (65536 - 50000) / 256; //高八位初始值
	TL0 = (65536 - 50000) % 256; //低八位初始值
```

低8位最大放下的数字为256（$2^8$），所以对256取余即是低8位的值。

比如：十进制数12345，低2位的值为，12345 % $10^2$  = 45。

高8位的值就是代表了有多少个低8位最大值的数。上例也就是123个$10^2$。

> 进一步，A % $2^n$，那就可以变成求A的低n位。那么两进制的与操作可以实现这一点

例如A % 256 = A % $2^8$ = A & 255。

因为$2^n - 1$，即是n位二进制数全部位为1的情况。即255 = 1111 1111。与1就是其本身，而高8位默认为0，与0全部为0。所以可以得到低8位的值。

```c
	TH0 = (65536 - 50000) >> 8 ; //高八位初始值
	TL0 = (65536 - 50000) & 255; //低八位初始值
```



## 数码管动态显示1000内的数字

> 动态显示的原理就是要快，迅速的让两个灯先后亮造成一起亮的假象。

头文件：`head.h`

```c
#include <reg52.h>

#ifndef HEAD_H
#define HEAD_H

sbit sectionChoice = P2^6; //段选 
sbit placeChoice = P2^7; //位选

typedef unsigned char uchar;
typedef unsigned int uint;

extern uchar table[16];

//初始化程序
void Initialize(void);

//延时程序，保证一个灯亮一段时间，要不然下一个灯还没亮，他就已经灭了
void Delayms(uint a);

//显示数字程序
void DisplayNumber(uint number);

//判断位数程序
void JudgeNumber(uint number);

#endif 
```

操作集：`operation.c`

```c
#include "head.h"
/************************************************
*												
*	延时程序：晶振频率11.0592MHZ，大约延时ams 	   
*												
*************************************************/
void Delayms(uint a)
{
	while(a--)
	{
		uchar i = 120;
		for (; i > 0; i--)
			;
	}
}

/************************************************
*	
*	函数名	：JudgeNumber											
*	函数功能：判断位数程序   
*	函数参数：number（要判断的数字）
*	返回值  ：count（位数）
*												
*************************************************/
void JudgeNumber(uint number)
{
	uchar count = 0;
	while (number < 0)
	{
		P1 = 0xfe;
	}
	while (number)
	{
		number /= 10;
		count++;
	}
	//大于三位
	while(count > 3)
	{
		P1 = 0x00;
	}	
}

/************************************************
*	
*	函数名	：DisplayNumber											
*	函数功能：显示数字程序  
*	函数参数：
*			count（位数）
*	返回值  ：空
*												
*************************************************/
void DisplayNumber(uint number)
{
	uchar tens = 0, hundreds = 0, units = 0;
	units = number % 10;
	hundreds = number / 100;
	tens = (number / 10) % 10;

	placeChoice = 1;
	P0 = 0xfb;
	placeChoice = 0;

	sectionChoice = 1;
	P0 = table[units];
	sectionChoice = 0;

	Delayms(5);//如果没有这句，由于太快
    //1. 会使这个灯没有延迟一段时间就亮，看起来像是一个一个亮的
    //2. 上面P0的输入可能影响到下面P0
	
	placeChoice = 1;
	P0 = 0xfd;
	placeChoice = 0;

	sectionChoice = 1;
	P0 = table[tens];
	sectionChoice = 0;

	Delayms(5);

	placeChoice = 1;
	P0 = 0xfe;
	placeChoice = 0;

	sectionChoice = 1;
	P0 = table[hundreds];
	sectionChoice = 0;

	Delayms(5);
}
/************************************************
*	
*	函数名	：Initialize											
*	函数功能：定时器中断0初始化启动程序   
*	函数参数：空
*	返回值  ：空
*												
*************************************************/
void Initialize(void)
{
	EA = 1;
	TMOD = 0x01;
	ET0 = 1;
	//50ms
	TH0 = (65536 - 50000) / 256;
	TL0 = (65536 - 50000) & 255;
	TR0 = 1;
}
```

主函数：`main.c`

```c
#include <reg52.h>
#include "head.h"

//共阴极数码管显示16进制数
uchar table[16] = {
	0x3F, 0x06, 0x5B, 0x4F,
	0x66, 0x6D, 0x7D, 0x07,
	0x7F, 0x6F, 0x77, 0x7C,
	0x39, 0x5E, 0x79, 0x71,
};
static uchar count = 0;
void timer0(void) interrupt 1 using 1
{
	TH0 = (65536 - 50000) / 256;
	TL0 = (65536 - 50000) & 255;
	count++;
}
int main(void)
{
	uint number = 0;
	Initialize();
	while (1)
	{
		if (count == 20)//1s一次
		{
			count = 0;
			number++;
		}
		JudgeNumber(number);
		DisplayNumber(number);
	}

	return 0;
}
```

## 独立键盘

![image-20210105101932895](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20210105101932895.png)

S2, S3, S4， S5四个键，分别接在P3.4, P3.5, P3.6, P3.7上，只要按下键，引脚就会是低电平，从而知道有按键按下。

```c
sbit KEY0 = P3^4; //独立键盘
sbit KEY1 = P3^5; 
sbit KEY2 = P3^6; 
sbit KEY3 = P3^7; 
```

头文件：`head.h`

```c
#ifndef _HEAD_H
#define _HEAD_H

#include <reg52.h>

sbit sectionChoice = P2^6;//段选口
sbit placeChoice = P2^7;//位选口
sbit KEY0 = P3^4; //独立键盘
sbit KEY1 = P3^5; 
sbit KEY2 = P3^6; 
sbit KEY3 = P3^7; 

typedef unsigned  char uchar;
typedef unsigned int uint;

extern uchar table[16];
//延时程序 
void Delayms(uint a);

//检测按键程序
void Test(uchar *p);

//数码管显示函数
void Display(uchar number);

#endif
```

操作集：`operation.c`

```c
#include "head.h"

/************************************************
*												
*	延时程序：晶振频率11.0592MHZ，大约延时ams 	
*												
*************************************************/
void Delayms(uint a)
{
	while(a--)
	{
		uchar i = 120;
		for (; i > 0; i--)
			;
	}
}
/************************************************
*												
*	函数名称：Display
*   函数功能：最后一个数码管以16进制显示传入数据 
*	参数：    number（要显示的数据）
*   返回值  ：空	
*												
*************************************************/
void Display(uchar number)
{
	placeChoice = 1;
	P0 = 0xfe;
	placeChoice = 0;
	Delayms(5);

	sectionChoice = 1;
	P0 = table[number];
	sectionChoice = 0;
	Delayms(5);
}
/************************************************
*												
*	函数名称：Test
*   函数功能：检测按键按下并做出相应操作
*	参数：    uchar类型的指针，用来更改变量
*   返回值  ：空	
*												
*************************************************/
void Test(uchar *p)
{
	if (!KEY0)
	{
		Delayms(5);
		if ( !KEY0)
		{
			(*p)++;
		}	
		while (!KEY0);			
		Delayms(10);
		while (!KEY0);
	}
	if (!KEY1)//此句也可以用while，但是如果真按下了也就会在下面的while停住，直到松手，除非有人手速快到在延时后的检测已松手，此句检测又按下。
    /*如果按键不涉及改变值，那用while还可以有检测松手的作用，因为不松手就一直在这个循环中*/
	{
		Delayms(5);
		if ( !KEY1)
		{
			(*p) += 2;
		}	
		while (!KEY1); //松手消抖检测，如果没有松手，就一直在这里循环			
		Delayms(10);
		while (!KEY1);
	}
	if (!KEY2)
	{
		Delayms(5);
		if ( !KEY2)
		{
			(*p) += 3;
		}	
		while (!KEY2);			
		Delayms(10);
		while (!KEY2);
	}
	if (!KEY3)
	{
		Delayms(5);
		if ( !KEY3)
		{
			(*p) += 4;
		}	
		while (!KEY3);			
		Delayms(10);
		while (!KEY3);
	}
	if (*p >= 16)
		*p = 0;		
}
```

主函数：`main.c`

```c
#include <reg52.h>
#include "head.h"

//共阴极数码管显示16进制数
uchar table[16] = {
	0x3F, 0x06, 0x5B, 0x4F,
	0x66, 0x6D, 0x7D, 0x07,
	0x7F, 0x6F, 0x77, 0x7C,
	0x39, 0x5E, 0x79, 0x71,
};
int main(void)
{
	uchar count = 0;
	P3 = 0xff;
	while (1)
	{
		Display(count);
		Test(&count);
	}
	return 0;
}

```

### 矩阵键盘

![image-20210105135334694](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20210105135334694.png)

如上图，如果P3.0端口被置为低电平，那么当S6按下时LCDEN(P3.4)也会变成低电平。只要在P3.0为低电平时，去检测四个高二进制位就可以判断低一行。

头文件：`head.h`

```c
#ifndef _HEAD_H
#define _HEAD_H

#include <reg52.h>

sbit sectionChoice = P2^6;//段选口
sbit placeChoice = P2^7;//位选口

typedef unsigned  char uchar;
typedef unsigned int uint;


extern uchar table[16];
extern uchar number[4];
//延时程序 
void Delayms(uint a);

//检测按键程序
void Test(uchar *p, uchar num);

//数码管显示函数
void Display(uchar number);

#endif
```

操作集：`operation.c`

```c
#include "head.h"

/************************************************
*												
*	延时程序：晶振频率11.0592MHZ，大约延时ams 	
*												
*************************************************/
void Delayms(uint a)
{
	while(a--)
	{
		uchar i = 120;
		for (; i > 0; i--)
			;
	}
}/************************************************
*												
*	函数名称：Display
*   函数功能：最后一个数码管以16进制显示传入数据 
*	参数：    number（要显示的数据）
*   返回值  ：空	
*												
*************************************************/
void Display(uchar number)
{
	placeChoice = 1;
	P0 = 0xfe;
	placeChoice = 0;
	Delayms(5);

	sectionChoice = 1;
	P0 = table[number];
	sectionChoice = 0;
	Delayms(5);
}
/************************************************
*												
*	函数名称：Test
*   函数功能：检测按键按下并做出相应操作
*	参数：    
*             uchar类型的指针p，用来更改变量
*			  num（用来改变P3）
*   返回值  ：空	
*												
*************************************************/
void Test(uchar *p, uchar num)
{
	uchar temp;
	P3 = num;
	temp = P3;
	temp = temp & 0xf0;
	//因为没有改变值，按下一个键就是一个数字，所以不需要松手检测，这里就放在while循环中
	while (temp != 0xf0)
	{
		Delayms(5);
		temp = P3;
		temp = temp & 0xf0;	
		if (temp != 0xf0)
		{	
			temp = P3;//用来确定16个按键中的哪一个是
			switch(temp)
			{
			//第一行，低四位中最低位为0，
				case 0xee://第一列，高四位中，最近位为0
					*p = 0;
					break;
				case 0xde://第一列，高四位中，次近位为0
					*p = 1;
					break;
				case 0xbe:
					*p = 2;
					break;
				case 0x7e:
					*p = 3;
					break;
			//第二行，低四位中次低位为0
				case 0xed:
					*p = 4;
					break;
				case 0xdd:
					*p = 5;
					break;
				case 0xbd:
					*p = 6;
					break;
				case 0x7d:
					*p = 7;
					break;

				case 0xeb:
					*p = 8;
					break;
				case 0xdb:
					*p = 9;
					break;
				case 0xbb:
					*p = 10;
					break;
				case 0x7b:
					*p = 11;
					break;

				case 0xe7:
					*p = 12;
					break;
				case 0xd7:
					*p = 13;
					break;
				case 0xb7:
					*p = 14;
					break;
				case 0x77:
					*p = 15;
					break;
			}
		}
	}
}
```

主函数：`main.c`

```c
/************************************
*
* 16个按键分别对应16个16进制数
*
************************************/
#include <reg52.h>
#include "head.h"

//共阴极数码管显示16进制数
uchar table[16] = {
	0x3F, 0x06, 0x5B, 0x4F,
	0x66, 0x6D, 0x7D, 0x07,
	0x7F, 0x6F, 0x77, 0x7C,
	0x39, 0x5E, 0x79, 0x71,
};

uchar number[4] = {
	0xfe, 0xfd, 0xfb, 0xf7,
};

int main(void)
{
	uchar count = 0;
	uchar num = 0;
	while (1)
	{
		Display(count);
		Test(&count, number[num]);
		
		num++;
		if (num >= 4)
			num = 0;
	
	}
	return 0;
}
```

==这样写case语句实在是太多了，换一种思路，可以先确定行再确定列。==将全部行线置0列线置1，当一个键按下后，可以确定其列。再将列线置0，行线置1，当一个键按下后，可以确定其行。

```c
#include "head.h"

/************************************************
*												
*	延时程序：晶振频率11.0592MHZ，大约延时ams 	
*												
*************************************************/
void Delayms(uint a)
{
	while(a--)
	{
		uchar i = 120;
		for (; i > 0; i--)
			;
	}
}/************************************************
*												
*	函数名称：Display
*   函数功能：最后一个数码管以16进制显示传入数据 
*	参数：    number（要显示的数据）
*   返回值  ：空	
*												
*************************************************/
void Display(uchar number)
{
	placeChoice = 1;
	P0 = 0xfe;
	placeChoice = 0;
	Delayms(5);

	sectionChoice = 1;
	P0 = table[number];
	sectionChoice = 0;
	Delayms(5);
}
/************************************************
*												
*	函数名称：Test
*   函数功能：检测按键按下并做出相应操作
*	参数：    空
*   返回值  ：要显示的值	
*												
*************************************************/
uchar Test(void)
{
	uchar tmp = 0;
	uchar number = 0;
	P3 = 0x0f;//低四位置1，高四位置0，确定行（低四位）
	Delayms(1);
	tmp = P3 ^ 0x0f; //异或，确定哪一位是0
	switch(tmp)
	{
		case 0:	
			number = 0;
			break;
		case 2:
			number = 4;
			break;
		case 4:
			number = 8;
			break;
		case 8:
			number = 12;
			break;
	}
	P3 = 0xf0; //高四位置1，确定列（高四位）
	Delayms(1);
	tmp = P3 >> 4 ^ 0x0f; //右移四位，再异或
	switch(tmp)
	{
		case 1:	
			number += 0;//第一列
			break;
		case 2:
			number += 1;//第二列
			break;
		case 4:
			number += 2;
			break;
		case 8:
			number += 3;
			break;
	}
	return number;
}
```

==这个的去抖和检测松手可以在调用这个函数之前开始。==

```c
#include <reg52.h>
#include "head.h"

//共阴极数码管显示16进制数
uchar table[16] = {
	0x3F, 0x06, 0x5B, 0x4F,
	0x66, 0x6D, 0x7D, 0x07,
	0x7F, 0x6F, 0x77, 0x7C,
	0x39, 0x5E, 0x79, 0x71,
};

int main(void)
{
	uchar number = 0;

	while (1)
	{
		P3 = 0xf0;
		if (P3 != 0xf0)
		{
			Delayms(5);
			if (P3 != 0xf0)
			{
				number = Test();
			}
			while(P3 != 0xf0);
		}	
		Display(number);
	}
	return 0;
}
```



### 键盘控制跑表

![image-20210105150235376](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20210105150235376.png)

头文件：`hea.h`

```c
#ifndef _HEAD_H
#define _HEAD_H

#include <reg52.h>

sbit sectionChoice = P2^6;//段选口
sbit placeChoice = P2^7;//位选口
sbit KEY0 = P3^4;
sbit KEY1 = P3^5;
sbit KEY2 = P3^6;
sbit KEY3 = P3^7;

typedef unsigned  char uchar;
typedef unsigned int uint;


extern uchar table[16];

//延时程序 
void Delayms(uint a);

//检测按键程序
void Test(uint *number);

//数码管显示函数
void DisplayNumber(uint number);

//初始化函数
void Initialize();

#endif
```

操作集：`operation.c`

```c
#include "head.h"
/************************************************
*												
*	延时程序：晶振频率11.0592MHZ，大约延时ams 	   
*												
*************************************************/
void Delayms(uint a)
{
	while(a--)
	{
		uchar i = 120;
		for (; i > 0; i--)
			;
	}
}

/************************************************
*	
*	函数名	：DisplayNumber											
*	函数功能：显示数字程序   
*	函数参数：
*			count（位数）
*	返回值  ：空
*												
*************************************************/
void DisplayNumber(uint number)
{
	uchar tens = 0, hundreds = 0, units = 0;
	units = number % 10;
	hundreds = number / 100;
	tens = (number / 10) % 10;

	placeChoice = 1;
	P0 = 0xfb;
	placeChoice = 0;

	sectionChoice = 1;
	P0 = table[units];
	sectionChoice = 0;

	Delayms(5);//如果没有这句，由于太快
    //1. 会使这个灯没有延迟一段时间就亮，看起来像是一个一个亮的
    //2. 上面P0的输入可能影响到下面P0
	
	placeChoice = 1;
	P0 = 0xfd;
	placeChoice = 0;

	sectionChoice = 1;
	P0 = table[tens];
	sectionChoice = 0;

	Delayms(5);

	placeChoice = 1;
	P0 = 0xfe;
	placeChoice = 0;

	sectionChoice = 1;
	P0 = table[hundreds];
	sectionChoice = 0;

	Delayms(5);
}
/************************************************
*	
*	函数名	：Initialize											
*	函数功能：定时器中断0初始化启动程序   
*	函数参数：空
*	返回值  ：空
*												
*************************************************/
void Initialize(void)
{
	EA = 1;
	TMOD = 0x01;
	ET0 = 1;
	//10ms
	TH0 = (65536 - 10000) / 256;
	TL0 = (65536 - 10000) & 255;
	TR0 = 1;
}
/************************************************
*	
*	函数名	：Test											
*	函数功能：检测按键并做相应的操作   
*	函数参数：指向number的指针
*	返回值  ：空
*												
*************************************************/
void Test(uint *number)
{
	uchar flag = 0;
	if(!KEY0)
	{
		Delayms(5);
		if(!KEY0)
		{
			TR0 = 0;
		}
		while(!KEY0)
			DisplayNumber(*number);
		TR0 = 1;
	}
	if(!KEY1)
	{
		Delayms(5);
		if(!KEY1)
		{
			TR0 = 0;
		}
		while(!KEY1)
			DisplayNumber(*number);
	}
	if(!KEY2)
	{
		Delayms(5);
		if(!KEY2)
			flag = 1; //加个标志位更稳定
		while(!KEY2)
			DisplayNumber(*number);
		if(flag == 1)
		{
			TR0 = 1;
			flag = 0;
		}
	}
	if(!KEY3)
	{
		Delayms(5);
		if(!KEY3)
		{
			TR0 = 0;
			*number = 0;
		}
		while(!KEY0)
			DisplayNumber(*number);
		TR0 = 1;
	}
}
```



主函数：`main.c`

```c
/*************************************
* 功能：按下第一个键停止，松手继续
* 		按下第二个键停止
*		按下第三个键启动
*		按下第四个键从0开始
**************************************/
#include <reg52.h>
#include "head.h"

static uint number = 0;

//共阴极数码管显示16进制数
uchar table[16] = {
	0x3F, 0x06, 0x5B, 0x4F,
	0x66, 0x6D, 0x7D, 0x07,
	0x7F, 0x6F, 0x77, 0x7C,
	0x39, 0x5E, 0x79, 0x71,
};

void timer0(void) interrupt 1 using 1
{
	TH0 = (65536 - 10000) / 256;
	TL0 = (65536 - 10000) & 255;
	number++;
}

int main(void)
{
	Initialize();
	while(1)
	{
		if (number > 999)
			number = 0;
		DisplayNumber(number);
		Test(&number);
	}
	
	return 0;
}
```



 

## A/D与D/A

> 单 片机是数字部件， 只能处理数字量，0和1，在实际应用场合，会有一些模拟量需要单片机来处理。此时单片机就需要连接 A/D和D/A。

A/D：Analog to  Digital Converter ：模数转换器（将模拟量转换为数字量）

D/A：Digital to  Analog Converter ：数模转换器（将数字量转换为模拟量）

### A/D转换原理

**模拟量->数字量**

1. 采样：周其地获取模拟信号的瞬时值，从而得到一系列时间上离散的脉冲采样值(a)
2. 保持：两次采样间，将前一次采样值保存下来(b)
3. 量化：将采样保持电路输出的模似电压转化为最小数字量单位整数倍
4. 编码：将量化后的数值通过编码用一个代码表示出来，代码就是A/D转换器输出的数字量

![image-20210106160926652](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20210106160926652.png)

### D/A转换原理

**数字量->模拟量**

D/A转化器是将离散的数字量转换为连接变化的模拟量

> 数模转换的思想基本与二进制数转换为十进制数的原理相似，在将二进制数转为十进制数时，需要将二进制各位的数值与其位的权值 相乘，然后相加即可得到相应的十进制数。

![image-20210106161122587](https://raw.githubusercontent.com/little-zhengjj/PicGo/master/img/image-20210106161122587.png)

> 数字量以串行或并行方式 输入，存储于数字寄存器中，各位分别控制对应的模拟电子开关，数字为1的位将在位权网络上产生与其权值成正比的电流值（由基准电压通过不同的电阻控制得到），由求和电路将各种权值相加，即可得到数字量对应的模拟量。

如上图，从右看，两个阻值为2R的电阻并连，总电阻为R，再与一个1R的电阻串联，加在一起还是2R。再与下一个2R并连。

从左向右看，将除第一个2R外的电阻看成是一个整体，那它们的总电阻就是2R。

所以：

${I_7} =  \frac V {2R}$

$I_6 = \frac {I_7}2 = \frac V{4R}$

$……$

如果数字信号全为1：

电流：$I_{01} = \frac I{2^8} * (2^7 + 2^6 + 2^5 + 2^4 + 2^3 + 2^2 + 2^1 + 2^0) $

### A/D转换的主要性能指标

1. 分辨率：其对输入模拟信号的分辨能力。一个n位二进制数输出的A/D转换器应能区分输入模拟电压的$2^n$个不同量级。

### D/A转换的主要性能指标

1. 分辨率：输入数字量的最低有效位发生变化时所对应的输出模拟量电压/电流的变化量，反映了输出模拟量的电小变化值。

   > 例始：5V电压采用8位DAC时，分辨率为5V/256 = 19.5mv

2. 线性度：实际转换曲线与理想直线的最大偏差，相对于满量程的百分比。

3. 绝对精度：实际与理论的最大误差（肯定不能比改变一位的差值还要大）

   1. 增益误差：数码全为1时的误差
   2. 零点误差：数码全为0时的误差
   3. 非线性误差
   4. 噪声

ADC0804时序图：

![image-20210106164452260](https://raw.githubusercontent.com/little-zhengjj/PicGo/master/img/image-20210106164452260.png)

![image-20210106165157751](https://raw.githubusercontent.com/little-zhengjj/PicGo/master/img/image-20210106165157751.png)

* 启动：从时序图可以看出，在$CS\neg$为低时。$WR$的一次负跳变（由高电平到低电平）和正跳变（由低电平到高电平）。
* 输出：$RD\neg$为低后一段时间后才会输出。图中这段时间是$t_{ACC}$。

![image-20210106165621036](https://raw.githubusercontent.com/little-zhengjj/PicGo/master/img/image-20210106165621036.png)

![image-20210106165644443](https://raw.githubusercontent.com/little-zhengjj/PicGo/master/img/image-20210106165644443.png)

![image-20210106165725514](https://raw.githubusercontent.com/little-zhengjj/PicGo/master/img/image-20210106165725514.png)

原理图中可以看出CSAD在P0^7口，用锁存器连接 。而$RD$和$WR$分别在P3\^7和P3\^6。

头文件：`head.h`

```c
#ifndef HEAD_H
#define HEAD_H
#include <reg52.h>

sbit wr = P3^6;
sbit rd = P3^7;

typedef unsigned char uchar;
typedef unsigned int uint;

//延时函数
void Delayms(uint a);
//初始化程序
void Initialize(void);
//启动程序
void Start(void);

#endif
```

操作集：`operation.c`

```c
#include "head.h"

/************************************************
*												
*	延时程序：晶振频率11.0592MHZ，大约延时ams 	   
*												
*************************************************/
void Delayms(uint a)
{
	while(a--)
	{
		uchar i = 120;
		for (; i > 0; i--)
			;
	}
}
void Initialize(void)
{
	P0 = 0x7f;
}
//启动AD转换
void Start(void)
{
	wr = 1;
	wr = 0;
	wr = 1;
}
```

主函数：`main.c`

```c
#include <reg52.h>
#include "head.h"

void main(void)
{
	Initialize();

	while(1)
	{
		Start();
		Delayms(50);//这段时间在转换中,芯片比较慢，所以如果想要动态显示，这个时间就要长一点。低于20ms是不行的 
        
		rd = 0; //芯片手册上，rd为低后，过一段时间数据才有效
		Delayms(5);
		rd = 1; //rd再次置高
		Delayms(5);
	}
}
```

## 串行接口技术

### 概述

* 并行通信：多位同时传输，不适合长距离
* 串行通信：数据在一根信号线一位一位的传输
  * 异步通信：有起始位和停止位
  * 同步通信：接收端与发送端要先建立同步

* 制式
  * 单工：数据只能单向传输
  * 半双工：通信双方都可以发送和接收数据，不可以同时
  * 全双工：通信双方都可以发送和接收数据，可以同时

### 串行口有四种工作方式

* 方式一：采用定时器T1方式2，8位自动重置方式。

  ​	波特率：每秒传送二进制代码的位数（也就是每位传送时间的倒数）

​						T1溢出率x$2^{SMOD}$/32

> T1溢出率：指的是溢出的频率，也就是一个单位时间溢出多少次

> >每个机器周期时间：12 x 时钟周期（振荡周期） = 12 x $\frac 1{f_{osc}}$
>
> > 定时器每个机器周期时间加1。
> >
> > 所以，T1溢出一次所需时间为：$\frac {12} {f_{osc}}*(256 - TH1)$(TH1是定时器初值)
> >
> > 所以：T1的溢出率为：$\frac{1}{\frac {12} {f_{osc}}*(256 - TH1)}$ = $\frac {f_{osc}}{12 * (256 - TH1)}$

可推得：

波特率 = $\frac {f_{osc}}{12 * (256 - TH1)}$x$2^{SMOD}$/32

定时器初值：TH1 = $256 - \frac {f_{osc}*2^{SMOD}}{波特率 * 12 * 32 }$

### 串行口结构

可编程全双工串行通信接口

![image-20210107130813326](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20210107130813326.png)

* 输入SBUF和输出SBUF两者有相同的逻辑地址， 但是有着不同的物理地址。
* 输入移位寄存器：从外部设备输入的串行数据转换为并行数据

### 串行口的工作原理

* 发送数据：
  * CPU通过内部总线将并行数据写入发送SBUF
  * 在发送控制电路的控制下， 按设定好的波特率，每来一次移位脉冲，通过引脚 TXD向外输出一位
  * 一帧数据发送结束后，现CPU发出中断请求，TI位置1
  * CPU响应中断后，开始准备发送下一帧数据
* 接收数据
  * CPU不停检测引脚RXD上的信号，当信号中出现低电平时
  * 在接收控制电路程的控制下，按设定好的波特率，每来一次移位脉冲，读取外部设备发送的一位数据到移位寄存器。
  * 一帧数据传输结束后，数据被存入接收SBUF，同时向CPU发出中断请求，RI位置1
  * CPU响应中断后，开始准备接收下一帧数据

头文件：`head.h`

```c
#ifndef HEAD_H
#define HEAD_H

typedef unsigned char uchar;
typedef unsigned int uint;

void Initialize(void);

#endif
```

操作集：`opreation.c`

```c
#include "head.h"
#include <reg52.h>

void Initialize(void)
{
	TMOD = 0x20; //定时器1，工作方式2
	TH1 = 0xfd; //波特率9600
	TL1 = 0xfd;
	
	TR1 = 1; //启动定时器1中断
	
	REN = 1; //允许串行接收
	SM0 = 0;
	SM1 = 1; //串行口工作方式1

	EA = 1; //开总中断
	ES = 1; //开串口中断
}
```

主函数：`main.c`

```c
#include <reg52.h>
#include "head.h"

static uchar flag = 0;

//如果SBUF已经收到数据
void External(void) interrupt 4
{
	RI = 0; //RI软件清零
	flag = 1;
	P1 = SBUF; //收到的值给P1
}
void main(void)
{
	Initialize();
	while(1)
	{
		if (flag)
		{
			flag = 0;
			//发送与接收同时用一个中断，在发送查询方法时将中断关闭
			ES = 0; 
			SBUF = P1; //发送SBUF收到值
			while(!TI); //等待发送完毕
			TI = 0; //打开TI
			ES = 1; //打开外部中断
		}
	}
}
```

程序可以看出：

* 发送SBUF：发送数据的那个SBUF，接收到从机给的数据，再送给主机
* 接收SBUF：接收数据的那个SBUF，接收到主机给的数据，再做出相应操作

## EEPROM

```c
#include <reg52.h>
#include <intrins.h>

//特殊功能寄存器
sfr ISP_DATA = 0xe2;      //数据寄存器
sfr ISP_ADDRH = 0xe3;     //操作时地址寄存器高8位
sfr ISP_ADDRL = 0xe4;
sfr ISP_CMD = 0xe5;       //命令寄存器
sfr ISP_TRIG = 0xe6;      //命令触发寄存器
sfr ISP_CONTR = 0xe7;     //控制寄存器

//定义命令
#define Read_COM 0x01
#define Write_COM 0x02
#define Erase_COM 0x03
#define En_WaitTime 0x81

//生效指令
#define effective() ISP_TRIG = 0x46;\
                    ISP_TRIG = 0xb9;\
                    _nop_()
//第一扇区起始地址
#define Fisrt_AddRH 0x20 //高地址
#define Fisrt_AddRL 0x00 //低地址

//关闭
void Close_EEPROM(void)
{
    ISP_CMD = 0x00;
    ISP_TRIG = 0x00;
    ISP_CONTR = 0x00;
}
//写
void EEPROM_Write(uint16 address, uchar8 dat)
{
    EA = 0;                                     //关中断
    ISP_CONTR = En_WaitTime;                    //等待、允许
    ISP_CMD = Write_COM;                        //送入写指令
    ISP_DATA = dat;                             //送入要写入的数据
    ISP_ADDRH = (uchar8)(address >> 8);         //送入要写入的地址的高8位
    ISP_ADDRL = (uchar8)(address & 0x00ff);
    effective();                                //生效
    Close_EEPROM();                             //关闭
    EA = 1;                                     //开中断
}
//读
uchar8 EEPROM_Read(uint16 address)
{
    EA = 0;                                     //关中断
    ISP_CONTR = En_WaitTime;                    //等待、允许
    ISP_CMD = Read_COM;                         //送入读指令
    ISP_ADDRH = (uchar8)(address >> 8);         //送入要读的地址的高8位
    ISP_ADDRL = (uchar8)(address & 0x00ff);
    effective();                                //生效  
    Close_EEPROM();                             //关闭
    EA = 1;                                     //开中断
    return ISP_DATA;
}
//擦除
void EEPROM_Erase(uint16 address)
{
    EA = 0;
    ISP_CONTR = En_WaitTime;                    //等待、允许  
    ISP_CMD = Erase_COM;                         //送入读指令
    ISP_ADDRH = (uchar8)(address >> 8);         //送入要擦除扇区的地址的高8位
    ISP_ADDRL = (uchar8)(address & 0xff);
    effective();                                //生效       
    Close_EEPROM();                             //关闭
    EA = 1;                                     //开中断  
}
```

# 看门狗

一、看门狗介绍
        在由单片机构成的系统中，由于单片机的工作有可能受到外界电磁场的干扰，造成程序的跑飞，从而陷入死循环，程序的正常运行被打断，单片机控制的系统便无法继续工作，这样会造成整个系统陷入停滞状态，发生不可预测的后果，所以出于对单片机运行状态进行实时监测的考虑，便产生了一种专门用于监测单片机程序运行状态的芯片，俗称“看门狗（Watch Dog）”。

        加入看门狗电路的目的是使单片机可以在无人状态下实现连续工作，其工作过程为：看门狗芯片和单片机的一个I/O引脚相连，该I/O引脚通过单片机的程序控制，使它定时地往看门狗芯片的这个引脚上送入高电平（或低电平），这一程序语句是分散地放在单片机其它控制语句中间的，一旦单片机由于干扰造成程序跑飞而陷入某一程序段进入死循环状态时，给看门狗引脚送电平的程序便不能被执行到，这时，看门狗电路就会由于得不到单片机送来的信号，便对它与单片机复位引脚相连的引脚送出一个复位信号，使单片机复位，从而使单片机从程序存储器的起始位置重新开始执行程序，这样便实现了单片机的自动复位。
    
        通常，看门狗电路是通过将一个专门的看门狗芯片连接到单片机来实现的，不过这样会给电路设计带来复杂性，STC系列单片机内部自带了看门狗，看门狗有一个15位的计数器，在缺省状态下，看门狗计数器不计数，看门狗功能禁止。如果使能了看门狗功能，则计数器由0开始计数，计数到最大值32767时，则单片机便产生复位。因此程序要定时对看门狗计数器进行清零，以避免计数器溢出而引起系统复位，这称之为“喂狗”。如果程序跑飞陷入死循环，则无法喂狗，看门狗就可以迫使单片机复位。
    
        通过对相应的特殊功能寄存器的设置就可实现看门狗的应用。STC89系列单片机内部有一个专门的看门狗定时器寄存器WDT_CONTR，这个寄存器的定义如下



这个寄存器中各位的定义分别为：

EN_WDT：看门狗允许位，当这一位设置为1时，使能看门狗。

CLR_WDT：看门狗清0位，当这一位设置为1时，将看门狗的计数器清0。

IDLE_WDT：看门狗空闲模式位，当这一位置1时，看门狗计数器在空闲模式下计数，当这一位清0时，看门狗计数器在空闲模式下不计数。

PS2\~PS0：看门狗计数器预分频系数。这三位用来设置看门狗计数器的计数周期。当采用12MHz的晶振，并采用12时钟模式时，PS2\~PS0对预分频值和看门狗的溢出时间的设置如下表所示。

![image-20210602102841542](https://i.loli.net/2021/06/02/hv6qWZCO5zgeoax.png)

        溢出时间是如何计算的呢，这需要对单片机的时钟模式进行一定了解。
    
        单片机的厂家不同，单片机的时钟系统也会有些差别。我们只介绍STC单片机的时钟。单片机有一下几个周期概念：

（1）时钟周期：也称为震荡周期，它定义为时钟频率的倒数，例如单片机的外部晶振为12MHz，则它的时钟周期就是1/12us，时钟周期是单片机中最基本、最小的时间单位，在一个时钟周期内CPU仅完成一个最基本的动作。时钟脉冲是单片机最基本的工作脉冲，它控制着单片机的工作节奏。对于一个单片机来讲，时钟频率越高，单片机的工作速度就越快，但是，由于不同的单片机内部硬件电路和电器结构不同，所以需要的时钟频率范围也不一定相同，我们使用的STC89C系列单片机的时钟范围约为1MHz~40MHz。

（2）状态周期：它是时钟周期的两倍。

（3）机器周期：单片机基本操作周期，在一个操作周期内，单片机完成一项基本的操作，如取指令、存储器读写等。

（4）指令周期：它是CPU执行一条指令所需要的时间，一般一个指令周期含有1~4个机器周期。

        STC单片机有两种时钟模式，一种是单倍速，也就是12时钟模式，在该时钟模式下，12个时钟周期为一个机器周期；另一种是双倍速，又称为6时钟模式，在该时钟模式下，6个时钟器为一个机器周期，比12时钟模式快1倍。两种时钟模式可以通过烧写软件进行设置。如下图所示。一般情况我们用12时钟模式就可以了。

![image-20210602103259316](https://i.loli.net/2021/06/02/3L5h68gt1NdUXVc.png)

        看门狗计数器的时钟源为机器周期，采用12MHz晶振，则时钟源的频率为1MHz，时钟源的周期为1us。若PS2~PS0设置为100，则分频系数为32，那么看门狗计数器的计数周期为32us，计数器由0计数到32767的时间长度为32us*32768=1048576us。即溢出时间为1.0485秒。

二、实例测试
        这个实验的代码如下所示，

```c
void main (void)
{
	WDT_CONTR=0x34;   //初始化看门狗，使能看门狗，溢出周期为1.0485s。 

	LED1=0;    //将P00口赋值0，对外输出低电平，灯点亮。
	delay1ms(500);   //延时0.5秒
	LED1=1;    //将P00口赋值1，对外输出高电平，灯熄灭。	
	for(;;)
	{
		WDT_CONTR=0x34;   //复位看门狗  
		delay1ms(500);    //延时0.5秒
	}
}
```

 烧写之后可以看到实验现象，开发板上的LED1闪1下之后熄灭。

在这个实验中，程序首先使能了看门狗，并且让LED1闪一下，之后，程序不对LED1进行操作，只是每隔0.5秒喂一次看门狗。

对程序进行一定修改，将for循环中的喂狗语句WDT_CONTR=0x34;   //复位看门狗  的前边打上双斜线//，将这一句隐去，这样程序只是使能了看门狗，而没有定时喂狗。将程序编译之后，将这个工程的HEX文件烧写到单片机中。烧写之后可以看到实验现象，开发板上的LED1每隔大约1秒闪一次，这是因为没有按时喂狗，单片机每隔1.0485s复位一次，每次复位之后LED1就闪一次。

程序中使用了WDT_CONTR这个寄存器。而这个寄存器在reg52.h头文件中没有进行定义，因此程序在使用这个寄存器之前要对其进行定义。这个寄存器的地址为E1H，因此将其定义为：sfr  WDT_CONTR = 0xE1;

## 1602液晶

`头文件head.h`

```c
#ifndef HEAD_H
#define HEAD_H
#include <reg52.h>
typedef unsigned char uchar;
typedef unsigned int uint;
sbit sectionChoice = P2^6;//段选
sbit placeChoice = P2^7;//位选
sbit lcden = P3^4; //液晶使能端
sbit lcdrs = P3^5; //数据命令选择端
extern uchar code array1[];
extern uchar code array2[];
void Initialize(void);
void Delayms(uint a);
void WriteCommand(uchar com);
void WriteData(uchar dat);
#endif
```

`操作集operation.c`

```c
#include "head.h"

/************************************************
*	
*	函数名	：Initialize										
*	函数功能：初始化函数
*	函数参数：空
*	返回值  ：空
*												
*************************************************/
void Initialize(void)
{
    sectionChoice = 0;
    placeChoice = 0; //数码管不能影响
    lcden = 0;//不读写数据，使能端为低电平
    WriteCommand(0x38);//显示模式设置
    WriteCommand(0x0f);//开显示光标，光标闪烁
    WriteCommand(0x06);//写后数据指针加一
    WriteCommand(0x80);//开头闪烁
    WriteCommand(0x01);//清屏
}
void Delayms(uint a);
/************************************************
*	
*	函数名	：WriteCommend											
*	函数功能：根据1602夜晶，将命令写入液晶
*	函数参数：com（要写入的命令）
*	返回值  ：空
*												
*************************************************/
void WriteCommand(uchar com)
{
	lcdrs = 0; //写指令时rs置低
	P0 = com;
	Delayms(5); //延时一段时间
	lcden = 1; //en置高一段时间
	Delayms(5);
	lcden = 0; //en置低
}
/************************************************
*	
*	函数名	：WriteData											
*	函数功能：根据1602夜晶，将数据写入液晶
*	函数参数：dat（要写入的数据）
*	返回值  ：空
*												
*************************************************/
void WriteData(uchar dat)
{
    lcdrs = 1;
	P0 = dat;
	Delayms(5); //延时一段时间
	lcden = 1; //en置高一段时间
	Delayms(5);
	lcden = 0; //en置低
}
/************************************************
*												
*	延时程序：晶振频率11.0592MHZ，大约延时ams 	   
*												
*************************************************/
void Delayms(uint a)
{
	while(a--)
	{
		uchar i = 120;
		for (; i > 0; i--)
			;
	}
}

```

`主函数main.c`

```c
#include <reg52.h>
#include "head.h"
uchar code array1[] = "2021-2-02Tuesday";
uchar code array2[] = "00:00:00";
void main(void)
{
    uchar i = 0; 
    uchar len1 = sizeof(array1) / sizeof(array1[0]);
    uchar len2 = sizeof(array2) / sizeof(array2[0]);

    Initialize();
    WriteCommand(0x80);
    for (i = 0; i < len1 - 1; i++)
    {
        WriteData(array1[i]);
    }
    WriteCommand(0x80 + 0x40 + 3);
    for (i = 0; i < len2 - 1; i++)
    {
        WriteData(array2[i]);
    }
    while(1);
}
```

![image-20210202213055961](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20210202213055961.png)

![image-20210202213131882](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20210202213131882.png)

![image-20210202213253753](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20210202213253753.png)

![image-20210202213321090](https://raw.githubusercontent.com/little-zhengjj/PicGo/master/img/image-20210202213321090.png)

# 51单片机指令表

|                        | 助记符         | 指令说明                       | 字节数 | 周期数 |
| ---------------------- | -------------- | ------------------------------ | ------ | ------ |
| **（数据传递类指令）** |                |                                |        |        |
| MOV                    | A，Rn          | 寄存器传送到累加器             | 1      | 1      |
| MOV                    | A，direct      | 直接地址传送到累加器           | 2      | 1      |
| MOV                    | A，@Ri         | 累加器传送到外部RAM(8 地址)    | 1      | 1      |
| MOV                    | A，#data       | 立即数传送到累加器             | 2      | 1      |
| MOV                    | Rn，A          | 累加器传送到寄存器             | 1      | 1      |
| MOV                    | Rn，direct     | 直接地址传送到寄存器           | 2      | 2      |
| MOV                    | Rn，#data      | 累加器传送到直接地址           | 2      | 1      |
| MOV                    | direct，Rn     | 寄存器传送到直接地址           | 2      | 1      |
| MOV                    | direct，direct | 直接地址传送到直接地址         | 3      | 2      |
| MOV                    | direct，A      | 累加器传送到直接地址           | 2      | 1      |
| MOV                    | direct，@Ri    | 间接RAM 传送到直接地址         | 2      | 2      |
| MOV                    | direct，#data  | 立即数传送到直接地址           | 3      | 2      |
| MOV                    | @Ri，A         | 直接地址传送到直接地址         | 1      | 2      |
| MOV                    | @Ri，direct    | 直接地址传送到间接RAM          | 2      | 1      |
| MOV                    | @Ri，#data     | 立即数传送到间接RAM            | 2      | 2      |
| MOV                    | DPTR，#data16  | 16 位常数加载到数据指针        | 3      | 1      |
| MOVC                   | A，@A+DPTR     | 代码字节传送到累加器           | 1      | 2      |
| MOVC                   | A，@A+PC       | 代码字节传送到累加器           | 1      | 2      |
| MOVX                   | A，@Ri         | 外部RAM(8 地址)传送到累加器    | 1      | 2      |
| MOVX                   | A，@DPTR       | 外部RAM(16 地址)传送到累加器   | 1      | 2      |
| MOVX                   | @Ri，A         | 累加器传送到外部RAM(8 地址)    | 1      | 2      |
| MOVX                   | @DPTR，A       | 累加器传送到外部RAM(16 地址)   | 1      | 2      |
| PUSH                   | direct         | 直接地址压入堆栈               | 2      | 2      |
| POP                    | direct         | 直接地址弹出堆栈               | 2      | 2      |
| XCH                    | A,Rn           | 寄存器和累加器交换             | 1      | 1      |
| XCH                    | A, direct      | 直接地址和累加器交换           | 2      | 1      |
| XCH                    | A, @Ri         | 间接RAM 和累加器交换           | 1      | 1      |
| XCHD                   | A, @Ri         | 间接RAM 和累加器交换低4 位字节 | 1      | 1      |
| **(算术运算类指令)**   |                |                                |        |        |
| INC                    | A              | 累加器加1                      | 1      | 1      |
| INC                    | Rn             | 寄存器加1                      | 1      | 1      |
| INC                    | direct         | 直接地址加1                    | 2      | 1      |
| INC                    | @Ri            | 间接RAM 加1                    | 1      | 1      |
| INC                    | DPTR           | 数据指针加1                    | 1      | 2      |
| DEC                    | A              | 累加器减1                      | 1      | 1      |
| DEC                    | Rn             | 寄存器减1                      | 1      | 1      |
| DEC                    | direct         | 直接地址减1                    | 2      | 2      |

| DEC  | @Ri      | 间接RAM 减1                  | 1    | 1    |
| ---- | -------- | ---------------------------- | ---- | ---- |
| MUL  | AB       | 累加器和B 寄存器相乘         | 1    | 4    |
| DIV  | AB       | 累加器除以B 寄存器           | 1    | 4    |
| DA   | A        | 累加器十进制调整             | 1    | 1    |
| ADD  | A,Rn     | 寄存器与累加器求和           | 1    | 1    |
| ADD  | A,direct | 直接地址与累加器求和         | 2    | 1    |
| ADD  | A,@Ri    | 间接RAM 与累加器求和         | 1    | 1    |
| ADD  | A,#data  | 立即数与累加器求和           | 2    | 1    |
| ADDC | A,Rn     | 寄存器与累加器求和(带进位)   | 1    | 1    |
| ADDC | A,direct | 直接地址与累加器求和(带进位) | 2    | 1    |
| ADDC | A,@Ri    | 间接RAM 与累加器求和(带进位) | 1    | 1    |
| ADDC | A,#data  | 立即数与累加器求和(带进位)   | 2    | 1    |
| SUBB | A,Rn     | 累加器减去寄存器(带借位)     | 1    | 1    |
| SUBB | A,direct | 累加器减去直接地址(带借位)   | 2    | 1    |
| SUBB | A,@Ri    | 累加器减去间接RAM(带借位)    | 1    | 1    |
| SUBB | A,#data  | 累加器减去立即数(带借位)     | 2    | 1    |



| (逻辑运算类指令) |               |                        |      |      |
| ---------------- | ------------- | ---------------------- | ---- | ---- |
| ANL              | A,Rn          | 寄存器“与”到累加器     | 1    | 1    |
| ANL              | A,direct      | 直接地址“与”到累加器   | 2    | 1    |
| ANL              | A,@Ri         | 间接RAM“与”到累加器    | 1    | 1    |
| ANL              | A,#data       | 立即数“与”到累加器     | 2    | 1    |
| ANL              | direct,A      | 累加器“与”到直接地址   | 2    | 1    |
| ANL              | direct, #data | 立即数“与”到直接地址   | 3    | 2    |
| ORL              | A,Rn          | 寄存器“或”到累加器     | 1    | 2    |
| ORL              | A,direct      | 直接地址“或”到累加器   | 2    | 1    |
| ORL              | A,@Ri         | 间接RAM“或”到累加器    | 1    | 1    |
| ORL              | A,#data       | 立即数“或”到累加器     | 2    | 1    |
| ORL              | direct,A      | 累加器“或”到直接地址   | 2    | 1    |
| ORL              | direct, #data | 立即数“或”到直接地址   | 3    | 1    |
| XRL              | A,Rn          | 寄存器“异或”到累加器   | 1    | 2    |
| XRL              | A,direct      | 直接地址“异或”到累加器 | 2    | 1    |
| XRL              | A,@Ri         | 间接RAM“异或”到累加器  | 1    | 1    |
| XRL              | A,#data       | 立即数“异或”到累加器   | 2    | 1    |
| XRL              | direct,A      | 累加器“异或”到直接地址 | 2    | 1    |
| XRL              | direct, #data | 立即数“异或”到直接地址 | 3    | 1    |
| CLR              | A             | 累加器清零             | 1    | 2    |
| CPL              | A             | 累加器求反             | 1    | 1    |
| RL               | A             | 累加器循环左移         | 1    | 1    |
| RLC              | A             | 带进位累加器循环左移   | 1    | 1    |
| RR               | A             | 累加器循环右移         | 1    | 1    |
| RRC              | A             | 带进位累加器循环右移   | 1    | 1    |
| SWAP             | A             | 累加器高、低4 位交换   | 1    | 1    |

| (控制转移类指令) |               |                                 |      |      |
| ---------------- | ------------- | ------------------------------- | ---- | ---- |
| JMP              | @A+DPTR       | 相对DPTR 的无条件间接转移       | 1    | 2    |
| JZ               | rel           | 累加器为0 则转移                | 2    | 2    |
| JNZ              | rel           | 累加器为1 则转移                | 2    | 2    |
| CJNE             | A,direct,rel  | 比较直接地址和累加器,不相等转移 | 3    | 2    |
| CJNE             | A,#data,rel   | 比较立即数和累加器,不相等转移   | 3    | 2    |
| CJNE             | Rn,#data,rel  | 比较寄存器和立即数,不相等转移   | 2    | 2    |
| CJNE             | @Ri,#data,rel | 比较立即数和间接RAM,不相等转移  | 3    | 2    |
| DJNZ             | Rn,rel        | 寄存器减1,不为0 则转移          | 3    | 2    |
| DJNZ             | direct,rel    | 直接地址减1,不为0 则转移        | 3    | 2    |
| NOP              |               | 空操作,用于短暂延时             | 1    | 1    |
| ACALL            | add11         | 绝对调用子程序                  | 2    | 2    |
| LCALL            | add16         | 长调用子程序                    | 3    | 2    |
| RET              |               | 从子程序返回                    | 1    | 2    |
| RETI             |               | 从中断服务子程序返回            | 1    | 2    |
| AJMP             | add11         | 无条件绝对转移                  | 2    | 2    |
| LJMP             | add16         | 无条件长转移                    | 3    | 2    |
| SJMP             | rel           | 无条件相对转移                  | 2    | 2    |



| (布尔指令) |          |                                |      |      |
| ---------- | -------- | ------------------------------ | ---- | ---- |
| CLR        | C        | 清进位位                       | 1    | 1    |
| CLR        | bit      | 清直接寻址位                   | 2    | 1    |
| SETB       | C        | 置位进位位                     | 1    | 1    |
| SETB       | bit      | 置位直接寻址位                 | 2    | 1    |
| CPL        | C        | 取反进位位                     | 1    | 1    |
| CPL        | bit      | 取反直接寻址位                 | 2    | 1    |
| ANL        | C,bit    | 直接寻址位“与”到进位位         | 2    | 2    |
| ANL        | C，/bit  | 直接寻址位的反码“与”到进位位   | 2    | 2    |
| ORL        | C,bit    | 直接寻址位“或”到进位位         | 2    | 2    |
| ORL        | C，/bit  | 直接寻址位的反码“或”到进位位   | 2    | 2    |
| MOV        | C,bit    | 直接寻址位传送到进位位         | 2    | 1    |
| MOV        | bit, C   | 进位位位传送到直接寻址         | 2    | 2    |
| JC         | rel      | 如果进位位为1 则转移           | 2    | 2    |
| JNC        | rel      | 如果进位位为0 则转移           | 2    | 2    |
| JB         | bit，rel | 如果直接寻址位为1 则转移       | 3    | 2    |
| JNB        | bit，rel | 如果直接寻址位为0 则转移       | 3    | 2    |
| JBC        | bit，rel | 直接寻址位为1 则转移并清除该位 | 2    | 2    |



| （伪指令） |                              |      |
| ---------- | ---------------------------- | ---- |
| ORG        | 指明程序的开始位置           |      |
| DB         | 定义数据表                   |      |
| DW         | 定义16 位的地址表            |      |
| EQU        | 给一个表达式或一个字符串起名 |      |

| DATA  | 给一个8 位的内部RAM 起名   |      |
| ----- | -------------------------- | ---- |
| XDATA | 给一个8 位的外部RAM 起名   |      |
| BIT   | 给一个可位寻址的位单元起名 |      |
| END   | 指出源程序到此为止         |      |

　

| （指令中的符号标识） |                                                         |
| -------------------- | ------------------------------------------------------- |
| Rn                   | 工作寄存器R0-R7                                         |
| Ri                   | 工作寄存器R0 和R1                                       |
| @Ri                  | 间接寻址的8 位RAM 单元地址（00H-FFH）                   |
| #data8               | 8 位常数                                                |
| #data16              | 16 位常数                                               |
| addr16               | 16 位目标地址，能转移或调用到64KROM 的任何地方          |
| addr11               | 11 位目标地址，在下条指令的2K 范围内转移或调用          |
| Rel                  | 8 位偏移量，用于SJMP 和所有条件转移指令，范围-128～+127 |
| Bit                  | 片内RAM 中的可寻址位和SFR 的可寻址位                    |
| Direct               | 直接地址，范围片内RAM 单元（00H-7FH）和80H-FFH          |
| $                    | 指本条指令的起始位置                                    |