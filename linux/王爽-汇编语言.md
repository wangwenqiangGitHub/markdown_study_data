# 汇编语言

## 前言

在学之前，搞清楚本书的重心：

> 通过学习关键指令来深入理解机器工作的基本原理，培养底层编程意识和思想。

读者应具备以下知识：

* 二进制、十六进制的知识
* 一门高级语言基本编程基础（顺序，选择，循环）

## 第一章：基本知识

###　位、字、字长、字节

* 位（bit，b）：是计算机中最小的数据单位，一个位的值只可能是0或1
* 字节（Byte，B）：8位是一个字节
* 字长：CPU在单位时间可以处理的最大二进制的位数。8位CPU，也就是单位时间内最大可以处理一字节。
* 字（Word，W)：计算机处理数据时，一次存取、加工、传送的数据的长度称为字。一个字通常是由多个字节构成。字长为32的CPU，一个字等于4个字节。显然，字与字长有关，可以理解为：一个字 = 字长/8。

### 机器语言

1. 机器语言是机器指令的集合
2. 机器指令展开来讲就是一台机器可以正确执行的命令。

### 汇编语言的产生

1. 汇编语言的主体是汇编指令
2. 汇编指令与机器指令的差别在于指令的表示方法上。汇编指令是机器指令便于记忆的书写格式。
3. 汇编指令是机器指令的助记符。

### 汇编语言的产生

机器只认识二进制，机器语言就是一堆二进制码。所有的高级语言写的源程序最终都会变成二进制，给机器运行。

> 机器语言人难写又难读，所以就用另一种人比较好看的语言来做这些事情，通过编译器最终转换成机器语言。

这个转换过程叫做翻译。

寄存器：CPU中可以存储数据的器件，一个CPU中有多个寄存器。

### 汇编语言的组成

1. 汇编指令（机器码的助记符，有对应的机器码）
2. 伪指令（没有对应的机器码，由编译器执行，计算机不执行）
3. 其它符号（由编译器识别，没有对应的机器码）

汇编语言的核心是汇编指令，它决定了汇编语言的特性。

### 存储器

CPU是计算机的核心部件，它控制整个计算机的运作并时进行运算，要想让一个CPU工作，就必须向它提供指令和数据。

指令和数据在存储器中存放， 也就是平时所说的内存。计算机中的硬件一般都有固定的存储，显卡，网卡，BIOS都有。

#### 存储单元

存储器被划分为若干个存储单元，每个存储单元从0开始编号。

**微机存储器的容量是以字节为最小单位来计算的**，一个存储单元就是1Byte，即8个二进制位。也就是说64KB就是10^16字节，字节单位已经是最小单位了，不能再细分了。

B=>KB=>MB=>GB=>TB  

### 指令和数据

在计算机的内存和磁盘上，只有二进制数。这些二进制数有两种可能，要么是数据，要么是指令。

### CPU对存储器的读写

1. 存储单元的地址（地址信息）
2. 器件的选择，读或写命令（控制信息）
3. 读或写的数据（数据信息）

![image-20201101094114574](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201101094114574.png)

地址线发出操作3这个地址，控制线说是读，数据线将08读入CPU。

同理：地址线发出操作3这个地址，控制线说是写，数据线将一个数据写进3这个内存单元。

### 三大总线

* 地址总线：

  * CPU是通过地址总线来指定**存储单元**的*(定位的是Byte，不是bit)*

    尤其要注意这里，能寻址的最小单元是字节单元，也就是说，这个单元上的二进制能表达256种可能。

  * 地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址

  > 一个CPU有N根地址总线，则可以说这个CPU的地址总线的宽度为N
  >
  > 其最多可以寻找2的N次方个内存单元（2^N byte）

  ![image-20201101094254062](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201101094254062.png)

* 控制总线

  * CPU对外部器件的控制是通过控制总线来进行的。在这里控制总线是个总称，控制总线是一些不同控制线的集合
  * 有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制，其宽度决定了CPU对外部器件的控制能力   

  > 内存的读或写命令是由几根控制线综合发出的：
  >
  > * 其中有一根名为读信号输出控制线负责由CPU向外传送读信号，CPU向该控制线上输出低电平表示将要读取数据
  > * 有一根名为写信号输出控制线负责由CPU由外传送写信号

  可以粗略的理解为每一条线对应一个东西，发送0、1进行读写。

* 数据总线

  * CPU和内存或其它器件之间的数据传送是通过数据总线来进行的
  * 数据总线的宽度决定了CPU和外界的数据传送速度
  
  数据总线与地址总线不同了，他的一根线就表示一位。8位数据（1byte）就要8根线，而地址线找地址一根就能找两种内存单元（byte）。

![image-20201101094337766](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201101094337766.png)

![image-20201101094420514](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201101094420514.png)

### 检测

1. 1个CPU的寻址能力为8KB，那么它的地址总线的宽度为_13__

8KB = 8192Byte = 2^13

2. 1KB的存储器有_1024____个存储单元。存储单元的编号从0到1023

1KB = 1024Byte

3. 1KB的存储器可以存储8192个bit，1024个Byte

4. 1GB、1MB、1KB分别是2^30、2^20、2^10Byte

5. 8080、8088、80286、80386的地址总线宽度分别为16根、20根、24根、32根，则它们的寻址能力分别为：2^6KB、1MB、16MB、4GB

6.  8080、8088、8086、80286、80386的数据总线宽度分别为8根、8根、16根、16根、32根，则它们一次可以传送的数据为：

1B、1B、2B、2B、4B

7. 从内存中读取1024字节的数据，8086至少要读_512__次，80386至少要读256了 次

8. 在存储器中，数据和程序以二进制形式存放

#### 注意点

> 地址总线寻址是从存储（内存）单元寻址的，从寻址来说，存储单元就是最小可编址单位，一般就是1Byte。一根就是1Byte。N根就是2^N个Byte。
>
> 数据总线一根就是一位。



>内存编址：存储器由许多可存放一段信息的单元（位置）组成，每个单元都有一个编号，程序可以通过这个编号来访问这个单元，这个编号就是这个单元的地址。

显然地址总线就是通过这个编号来访问每一个地址单元的，而地址线一根就是两种状态，通过组合又组成了多种状态来找到这个编号。 如果有6个单元就至少需要3根线（2^3=8）。

### 内存地址空间

> 一个CPU地址总线宽度为10，那么可以寻址1024个内存单元（Byte)，这个1024个可寻址的单元就构成了CPU的内存地址空间。

#### 主板

> 主板上有一些主要部件和一些核心器件，这些器件通过三大总线相连。CPU、存储器、外围芯片组、扩展卡槽等

#### 接口卡

> 计算机系统中，所有可用程序控制其工作的设备，都要受到CPU的控制，但是CPU并不能直接控制这些设备，直接控制这些的是在扩展卡槽上的接口卡，扩展卡槽通过总线与CPU相连，所以接口卡也相连。CPU可以直接控制这些接口卡，来间接的控制这些外部设备。

CPU ——> 接口卡——>外设

#### 各类存储器芯片

> 一台PC机中，装有多个存储器芯片。
>
> 物理上来看这些芯片是独立的，从读写属性上分为两类
>
> * RAM 可读写，掉电内容丢失
> * ROM 只读

从功能和连接上分为

> 1. 随机存储器RAM
>
>    用于存放CPU使用的绝大部分数据和程序，主随机存储器一般由两个位置上的RAM组成
>
>    1. 装在主板上RAM
>    2. 插在扩展插槽上的RAM
>
> 2. 装有BIOS(Basic Input/Output System)的ROM
>
>    BIOS是由主板和各类接口卡厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入与输出。
>
>    主板有主板的BIOS
>
>    显卡有显卡的BIOS
>
>    如果网卡有ROM，那其中就可以存储网卡的BIOS
>
> 3. 接口卡上的RAM
>
>    某些接口卡需要对大批量输入、输出数据进行暂时存储，在其上装有RAM。
>
>    典型的是显卡上的显存，显示卡随时将显存中的数据向显示器上输出，将需要的内空写入显存，就会出现在显存中。

![image-20201101094448557](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201101094448557.png)

#### 内存地址空间

上面的存储器在物理上是独立的，但是下面两点是相同的

* 都和CPU的总线相连
* CPU对它们进行读或写的时候都通过控制线发出内存读写命令

**CPU在操控它们时，把它们都当作了内存看待，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个存储器就是内存地址空间**

![image-20201101094511349](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201101094511349.png)

所有物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。CPU在这段地址空间中读写数据，实际上就是在对应的物理存储器中读写数据。



**内存地址空间大小受CPU地址总线宽度的限制**，8086CPU地址总线宽度为20，所以8086PC内存地址空间为1MB（2^20Byte），80386地址总线为32，则PC内存地址空间为4GB（2^32Byte）。

![image-20201101101431711](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201101101431711.png) 

## 第二章：寄存器

> 一个典型的CPU由运算符、控制器、寄存器等器件构成，这些器件靠内部总线相连。

前一章说的总线相对于CPU内部而言其实是外部总线，而内部也有一个总线，实现了CPU内部各个器件之间的联系，外部总线实现CPU和主板上其他器件的联系。

### 在CPU内部

* 运算器进行信息处理
* 寄存器进行信息存储
* 控制器控制各种器件进行工作
* 内部总线连接各种器件，在它们之间进行数据传送

对于汇编程序员来说，CPU中的主要部件是寄存器。寄存器是CPU中程序员可以用指令读写的部件。程序员通过改变各种寄存器中内容来实现对CPU的控制。

**这里的寄存器是在CPU中的**

### 8086CPU

> 8086CPU中的所有寄存器都是16位的

#### 通用寄存器

AX、BX、CX、DX

为了兼容上一代的8位寄存器， 这4个寄存器都可以分为两个可独立使用的8位寄存器。

以AX为例高8位AH，低8位AL。

![image-20201101104421709](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201101104421709.png)

![](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201101104520635.png)

上面的AX最高位少了一个0

### 字在寄存器中的存储

8086CPU：

* 字节：Byte，8bit
* 字：两个字节，就是16位，分别是高位字节和低位子节

 ### 几条汇编指令

![image-20201101110211359](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201101110211359.png)

汇编指令和寄存器名称不区分大小写。

![image-20201101110710918](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201101110710918.png)

 ![image-20201101110753602](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201101110753602.png)

### 检测

>(1) 写出每条汇编指令执行后相关寄存器中的值。

```
mov ax,62627  AX=F4A3H 

mov ah,31H   AX=31A3H 

mov al,23H   AX=3123H 

add ax,ax   AX=6246H 

mov bx,826CH  BX=826CH 

mov cx,ax   CX=6246H 

mov ax,bx   AX=826CH 

add ax,bx   AX=04D8H 

mov al,bh   AX=0482H 

mov ah,bl   AX=6C82H 

add ah,ah   AX=D882H 

add al,6    AX=D888H 

add al,al   AX=D810H 

mov ax,cx   AX=6246H
```



检测点2.1

(2) 只能使用目前学过的汇编指令，最多使用4条指令，编程计算2的4次方。 

```
mov ax,2     AX=2 

add ax,ax    AX=4 

add ax,ax    AX=8 

add ax,ax    AX=16 
```

2个2，2个4，2个8



### 物理地址

CPU访问内存单元时，要给出内存单元的地址，所有内存单元给同的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，这个地址就是物理地址。

CPU通过地址总线送入存储器的，必须是一个内存单元的物理地址。而这个物理地址，不同的CPU有不同的形成方式。

### 8086CPU（16位结构的CPU）

**16位的CPU（16位机，字长为16位）**，意味着：

* 运算器一次最多可以处理16位数据
* 寄存器最大宽度为16位
* 寄存器和运算器之间的最大通路为16位

也就是说，在8086**内部**，能够一次性处理、传输、暂时存储的信息的最大长度是16位的。



### 8086CPU给出物理地址的方法

8086CPU有20位的地址总线，达到1MB的寻址能力，8086CPU又是16位的结构，如果从内部发出的话，也只能发出16位，8086CPU用段地址+偏移地址的方法来形成一个20位的物理地址。



![image-20201101170250626](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201101170250626.png)

物理地址=段地址*16 + 偏移地址

乘16也就意味着16进制数左移一位，也就是16位的2进制数变成了20 位的2进制数，再加上这个偏移地址，就形成了可以确定的20位的物理地址。

### 段的概念

要注意的是，内存其实没有分段，是CPU搞出来的段地址。

下面两张图：

可以认为左边的10000H-100FFH组成一个段，起始地址为10000H，段地址为1000H，大小为100FFH-10000H = 100H

可以认为右边的10000H-1007FH组成一个段，10080H-100FFH组成一个段，大小都为80H。

![image-20201101170827474](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201101170827474.png)

可以看出，起始地址=段地址*16，必然是16的倍数。

在8086CPU中，偏移地址是16位，最大寻址是64KB，0000H-FFFFH，想要两个段接得上，段的长度应该是64KB。

### 总结

> 在8086PC机中，存储单元的地址用两个元素来描述，段地址和偏移地址。
>
> 数据在21F60H内存单元中，一般不这么说，要说：
>
> * 数据在2000：1F60单元中
> * 数据在2000段中的1F60H单元

检测点2.2

(1) 给定[段地址](https://www.baidu.com/s?wd=段地址&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)为0001H，仅通过变化[偏移地址](https://www.baidu.com/s?wd=偏移地址&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)寻址，CPU的寻址范围为 0010H 到 1000FH 。

```
解题过程：

物理地址＝SA*16+EA  

EA的变化范围为0h~ffffh  

物理地址范围为(SA*16+0h)~(SA*16+ffffh)  

现在SA=0001h,那么寻址范围为  

(0001h*16+0h)~(0001h*16+ffffh)  

=0010h~1000fh   
```

(2) 有一数据存放在内存20000H单元中，现给定段地址为SA，若想用偏移地址寻到此单元。则SA应满足的条件是：最小为 1001H ，最大为 2000H 。

当段地址给定为 1001H 以下和 2000H 以上，CPU无论怎么变化偏移地址都无法寻到20000H单元。

 ```
解题过程：

物理地址＝SA*16+EA  

20000h＝SA*16+EA  

SA=(20000h-EA)/16=2000h-EA/16  

EA取最大值时,SA=2000h-ffffh/16=1001h,SA为最小值  

EA取最小值时,SA=2000h-0h/16=2000h,SA为最大值 
 ```

如果先减再除，会以有数据丢失：

```
20000H = SA*16 + EA

20000H - FFFFH = SA *16

10001H = SA * 16

SA = 1000H
```

显然丢失了一个16进制位。

### 段寄存器

8086CPU在访问内存时需要段地址与偏移地址，送入地址加法器合成物理地址。这里就是由寄存器提供地址，**段寄存器提供段地址。**

8086CPU有4个段寄存器：

* CS（Code Segment）
* DS（Data Segment）
* SS（Stack Segment）
* ES（Extra Segment）

### CS和IP

IP（instruction point）：指令指针寄存器

8086PC机中，CS中的内容为M，IP中的内容为N，8086将从M*16 + N的内存单元开始，读取一条指令并执行。

IP执行完当前指令后会自动移到下一条指令的位置。如果当前指令是3个字节那就加3，如果是两个字节就加2。

8086CPU工作过程：

1. 从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器
2. IP = IP+所读取的指令的长度， 从而指向下一条指令
3. 执行指令。转到步骤1，重复这个过程

在8086CPU加电启动或复位，CS = FFFFH，IP = 0000H，FFFF0H是开机后的第一条指令。

**CPU将CS、IP中的内容当作指令的段地址和偏移地址**

### 修改CS、IP

程序员可以通过改变CS、IP中的内容来控制CPU执行目标指令。

```
jmp 段地址：偏移地址 
```

用指令中给出的段地址修改CS，偏移地址修改IP

```
jmp 偏移地址
```

改变IP

CPU只认被CS：IP指向的内存单元中的内容为指令。

## 实验1

debug

R：查看，修改CPU中寄存器的内容

D：查看内存中的内容，默认128字节，也可以自定义长度 

```
-d 0000:0 7f（128字节，0-7f）
```

E：修改内存中的内容

U：将内存中的内容解释为对应的汇编指令

A：以汇编指令的形式向内存中写入指令



## 第三章：寄存器（内存访问）

 第二章从CPU如何执行指令的角度讲解了8086CPU的逻辑结构、形成物理地址的方法、相关寄存器以及一些指令。

这一章从访问内存角度学习寄存器。

### 内存中的存储

数据和程序在内存中，都是二进制文件，能访问的地址也就是一个字节，用16进制来表示。CPU中，用16位寄存器来存储一个字，高8位存放高字节，低8位放低字节。

![image-20201103223538843](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201103223538843.png)

上图的0，1，2，3……就是能访问到的地址，用16进制来表示一个字节，比如20H，4EH等等。

由于内存单元是字节单元，则一个字就要用两个连续的内存单元来存。图中0、1两个内存单元存放数据4E20H，0是低地址单元，1是高地址单元。

> :字单元：存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成，高地址内存单元中存放字型数据的高位字节，低地址内存单元存放字型数据的低位字节。

以起始地址为N的字单元简称N地址字单元。

### DS和address

CPU要读写一个内存单元时，必须先给出这个内存单元的地址，在8086PC中，内存地址由段地址和偏移地址组成。

8086CPU中有一个DS寄存器用于存放段地址（注意DS寄存器也应该是16位的，不是20位的）

```
mov bx, 1000H
mov ds, bx
mov al, [0]
//将1000:0中的数据读到al中
```

为什么不能是

```
mov ds 1000H
```

因为8086CPU不支持将数据直接送入段寄存器（设计缺陷）

传送多少的数据是由最后的通用寄存器决定的，如果是ax、bx就传16位，最大也就只能传16位，而如果是al、ah，那就传送8位。

### 字的传送

8086CPU是16位结构，一次传送16位数据。

```
mov bx, 1000H
mov ds, bx
mov ax, [0]
mov [0], cx
```

16进制数一个数字代表四个二制数，4个数就是16个二进制数，也就是16位。

> 高位在高地址，低位在低地址

### mov、add、sub指令

1. mov 指令可以对寄存器，数据，内存单元之间的随意赋值
2. add、sub指令不可以用于段寄存器（以s结尾的寄存器segment）

### 数据段

> 可以将一组长度为N<=64KB、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间。

ds中存放数据段的段地址，再自己根据需要访问段中的单元。

### 栈

> 栈是一个存储空间，据有特殊的访问方式。先进后出，First in last out

由图形来看的话就也是一段空间，如下图，但是注意这段空间高地址在下面，低地址在上面。 

![image-20201107172205794](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201107172205794.png)

### CPU提供的栈机制

> ss:sp在任意时刻都指向栈顶元素，push入栈，pop出栈

在刚开始时，栈的长度是sp所决定的，ss为段地址，也就是低地址，在图上来说就是在上方，而sp始终指向栈顶，当栈为空时，栈顶应该在栈的最底部的下面。也就是最高地址的后面。按上图10000H~1000FH来说，ss=1000H，sp=10H。长度就是16byte。

### 栈顶越界问题

如果一直push肯定总有一天会满栈然后越界，如果一直pop，肯定总有一天会空栈然后也越界。要求编程人员自己注意。

### push、pop指令

* push

```
push 寄存器 将寄存器中的数据入栈
```

1. sp = sp-2，先让sp指向当前栈顶前面的单元，也就是将要送入数据的单元
2. 将寄存器中的内容送入ss:sp指向的内存单元，此时ss:sp就指向新栈顶

* pop

```
pop 寄存器 将栈中的数据送入寄存器
```

1. 将ss:sp指向的内存单元中的数据送入到寄存器中

2. sp = sp+2，让sp指向当前栈顶下面的内存单元，以这个单元为新的栈顶

8086CPU是16位的CPU，所以一次操作16位二进制数据，也就是4位16进制数据。一个内存单元中的数据是一个字节，也就是8位数据，在push和pop时，一次改变两个内存单元。

### 栈段

> 栈段就是当作栈来使用的一段空间。显然sp<=64KB（ffff），所以栈段最大不超过64KB

比如 10010H~1001FH，这是一个16字节的内存单元。



## 第四章：第一个程序

### 一个源程序从写出到执行的过程

1. 编写汇编源程序

2. 对源程序进行编译连接

   编译产生目标文件，windows下生成.obj文件

   连接生成可执行文件，windows下生成.exe文件

3. 执行可执行文件中的程序

### 源程序

```
1. assume cs:codesg ;假设某一段寄存器和程序中的某一个用segment……ends定义的段相关联

1. codesg segment ;定义一个段，段名为codesg，这个段从此开始
	
2.	mov ax, 0123
	mov bx, 0456
	add ax, bx
	add ax, ax
	
	mov ax, 4c00
	int 21

1. codesg ends ;名称为codesg的段到此结束

1. end ;结束编译
```



1. 伪代码
2. 程序
3. 标号：codesg这个标号指代了一个地址，这个段的名称最终会被编译、连接程序处理为一人段的段地址

#### 结构

1. 定义一段，名为abc

```
abc segment
……
abc ends
```

2. 在这个段中写入汇编指令

```
abc segment

	mov ax, 2
	add ax, ax
	
abc ends
```

3. 指出程序何时结束

```
abc segment

	mov ax, 2
	add ax, ax
	
abc ends

end
```

4. 与寄存器相关联

```
assume cs:abc

abc segment

	mov ax, 2
	add ax, ax
	
abc ends

end
```

5. 程序要返回

```
assume cs:abc

abc segment

	mov ax, 2
	add ax, ax
	mov ax, 4c00
	int 21
	
abc ends

end
```

**windows下在DOSbox中使用masm软件**

### 编译

源文件后缀应该是.asm。

```
masm 1(,asm)
```

生成.obj文件

### 连接

```
link 1
```

简化方式

```
masm 1;
link 1;
这样就不用总是点空格了
```

### 执行

```
1
```

### Debug

```
debug 1.exe
```

![image-20201107221918985](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201107221918985.png)

DOS系统中.exe文件的加载过程：

1. 程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0，程序所有内存区的地址就为ds:0
2. 这个内存区的前256个字节也就是16x16字节，放的是PSP，DOS用来和程序进行通信。这之后就是程序。

DS就是PSP的段地址SA，程序的段地址就是SA:0 + 256 = SA + 10 : 0

段地址大小最后是要乘16的，所以16*16 = 256

## 第五章：[bx]和loop指令

* [bx]和内存单元的描述

> [bx]和[0]类似，段地址在ds中，偏移地址在[]中，
>
> 要完整的描述一个内存单元要两个信息
>
> 1. 内存单元的地址
> 2. 内存单元的长度

* 定义()

()表示一个寄存器或者一个内存单元中的内容

(ax)就是ax寄存器中的内容

()中的内容可以是三种类型

1. 寄存器名 (ax)
2. 段寄存器名 (ds)
3. 内存的物理地址 ((ds)*16 + (bx))

* idata表示常量

```
mov ax, [1]
```

可以用idata来统一表示[]中的数字

### [BX]

![image-20201110093409284](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201110093409284.png)

这其中，[bx]就是表示以ds为段地址，以bx为偏移地址的内存单元。

### loop

此指令就是循环

```
s:  add ax, ax
	loop s ;cx = cx - 1
```

循环多少次是要有一个条件，这里用cx中的内容，如果cx为0就终止循环，而且每执行到loop s此条语句时cx = cx - 1

显然，如果cx = 1， 那就执行一次add

​			如果cx = 2，那就执行二次add

​			如果cx = n， 那就执行n次add

### 例题：用加法计算123*236

有两种加法方式：

1. 将123加236次
2. 将236加123次

显然第二种更快。

```
assume cs:code

code segment
	mov ax, 0
	mov cx, 123
s:  add ax, 236
	loop s
	
	mov ax, 4c00h
	int 21h

code ends

end
```

### 例题：计算ffff:0006单元中的数乘以3，结果放在dx中

这里要考虑的问题有以下几个：

1. 能不能存的下
2. 谁来存，怎么用循环
3. ffff:0006是一个字节型数据，如果直接mov到dx中的话肯定会加上ffff:0007怎么才能让高8位不赋过去？或者说将高8位清0

```
assume cs:code

code segment
	mov ax, 0ffffh ;在汇编源程序中，数据不能以字母开头
	mov ds, ax
	mov bx, 6
	
	mov al, [bx] 
	mov ah, 0 ;不能保证ah就一定不是0
	
	mov dx, 0
	
	mov cx, 3
	
s:  add dx, ax ;将ax中的值给dx
	loop s
	
	mov ax, 4c00h
	int 21h

code ends

end
```

### Debug命令

> g IP CS:IP前的程序被执行

> 下一条语句是loop时，可以用p命令结束循环

### Debug和汇编编译器masm对指令的不同处理

```
mov ax, [1]
```

Debug将它解释为[idata]，idata是内存单元的偏移地址

masm将它解释为idata，就是一个普通的数字

* 如果要在编译器中实现Debug中的功能，可以用普通寄存器做一个过渡。

```
mov ax, 2000h
mov ds, ax
mov bx, 0
mov al, [bx] ;将ds:bx单元中的数据送入al中
```

* 也可以用在[idata]前面加上段地址:

```
mov ax, 2000h
mov ds, ax
mov al, ds:[0] 
```

这两段代码实现同样的功能

### loop和[bx]的联合使用

#### 例题：计算ffff:0~ffff:b单元中数据的和，结果存在dx中

字节数据放到通用寄存器中，记得高位清0

用一个通用寄存器bx来增长

```
assum cs:code
code segment
	
	mov ax, 0ffffh
	mov ds, ax
	
	mov bx, 0
	mov cx, 12
	
	mov dx, 0
	
s:  mov cl, [bx] ;mov al, [bx]
	mov ch, 0 ;mov ah, 0
	
    mov dx, cx ;mov dx, ax
	inc bx
	loop s
	
	mov ax, 4c00h
	int 21h
	
code ends
end
```

### 段前缀

```
mov ax, ds:[bx]
mov ax, cs:[bx]
```

这里cs，ds就是段前缀

### 一段安全的空间

> 我们面临一种选择，是在操作系统中安全、规矩的编程，还是自由、直接的用汇语言去操作真实的的硬件，了解那此早已被层层系统软件掩盖的真相？在大部分的情况下，我们选择后者。

### 段前缀的使用

#### 例题：将内存ffff:0\~ffff:b单元中的数据复制到0:200\~020b单元中

```
assume cs:code

code segment
	
	mov bx, 0
	mov cx, 12
	
s:  mov ax, 0ffffh
	mov ds, ax
	mov dl, [bx]
	
	mov ax, 0020h
	mov ds, ax
	mov [bx], dl ;送入到的是一个字节空间，而不是一个字空间，所以就不用将dh清0
	
	inc bx
	loop s
	
	mov ax, 4c00h
	int 21h
	
code edns
end
```

每次设置ds太麻烦了

```
assume cs:code

code segment
	
	mov ax, 0ffffh
	mov ds, ax
	
	mov ax, 0020h
	mov es, ax	
	
	mov bx, 0
	mov cx, 12
	
s:  mov dl, [bx]
	mov es:[bx], dl
	
	inc bx
	loop s
	
	mov ax, 4c00h
	int 21h
	
code edns
end
```

### 实验4[bx]和loop的使用

1. 编程，向内存0:200\~0:23F依次传送数据0\~63（3FH)

```
assume cs:code

code segment
    mov ax, 20h
    mov ds, ax
    
    mov bx, 0
    mov cx, 40h
    
s:  mov [bx], bx
    inc bx
    loop s

    mov ax, 4c00h
    int 21h

code ends

end
```

2. 下面程序的功能是将mov ax, 4c00h之前的指令复制到内存0:200处，补全程序。上机调试，跟踪运行结果。

```
assume cs:code

code segment

    mov ax, code ;段的名称就存放着段的首地址
    mov ds, ax

    mov ax, 0020h
    mov es, ax
    mov bx, 0

    sub cx, 0008h
s:  mov al, [bx]
    mov es:[bx], al
    inc bx
    loop s

    mov ax, 4c00h
    int 21h
code ends
end
```

加载之初cx的值，就是汇编指令对应的机器数的大小。

debug后r一下得到cx = 001d，最后两个指令是5个字节，所以cx为0008

## 第六章：包含多个段的程序

前面的程序只有一个代码段，如果想要其它空间来存放程序，就需要其它空间来存，如果自己来分配的话，可能导致空间不安全，让操作系统来分配就不会出现这样的问题。

* 程序取得空间的两种方式 

1. 在加载程序的时候为程序分配
2. 程序在执行过程中向系统申请

原先已经说过，程序头的段地址在cs中，那么其它的内容（不是程序中的内容就应该在其它的段中），这样就有了多个段。

### 在代码段中使用数据

```
assume cs:code

code segment

    dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h

start:
        mov bx, 0
        mov ax, 0

        mov cx, 8

    s:  add ax, cs:[bx]
        add bx, 2
        loop s

        mov ax, 4c00h
        int 21h

code ends

end start
```

这里说明一下，start和end  start是改变ip地址的，cs指向的是程序的头，但是在这段代码中cs:0与cs:1上存放的是2301，dw所定义的数据总共就占了10h（16）个字节。所以`mov bx, 0`的位置应该是cs:10。ip就应该是从10开始执行，写程序时可以人为设定start后面开始代码的地址就是ip。

> end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。用end指令指明了程序入口在start处。

程序的框架：

```
assume cs:code

code segment
		*
		数据
		*
start:
		*
		代码
		*
code ends
end start
```

### 在代码段中使用栈

```
assume cs:code

code segment

    dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h

    dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

start:  mov ax, cs 
        mov ss, ax	;将程序的段入口处设为栈段，也就是上面数据开始，0123h
        mov sp, 30h ;将栈指针sp偏移30h

        mov bx, 0
        mov cx, 8 ;一次传一个字节，总共就要传8次
   s:   push cs:[bx] ;元素入栈
        add bx, 2
        loop s

        mov bx, 0
        mov cx, 8
  s0:   pop cs:[bx] ;元素出栈
        add bx, 2
        loop s0

        mov ax, 4c00h
        int 21h

code ends

end start
```

### 将数据、代码、栈放入不同的段

> 如果将数据、代码都放入同一个段，那么就会显得混乱。
>
> 可以用一个段来存放一种数据。

```
assume cs:code, ds:data, ss:stack

data segment

    dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987h

data ends

stack segment

    dw 0,0,0,0,0,0,0,0

stack ends    

code segment

start:  mov ax, stack ;ax在栈段
        mov ss, ax ;给栈段
        mov sp, 20h ;16个字型数据，32个字节

        mov ax, data 
        mov ds, ax ;把数据段给ds

        mov bx, 0
        
        mov cx, 8
    s:  push [bx] ;将data中的数据入栈
        add bx, 2
        loop s

        mov bx, 0

        mov cx, 8

    s0: pop [bx] ;将栈入数据送入到data中
        add bx, 2
        loop s0

        mov ax, 4c00h
        int 21h
code ends

end start
```

以上代码：数据存放在了一个段中，而栈也存放在了一个段中

* 定义多个段的方法

  与前面定义代码段没有区别，只是自己要想好名字

* 对段地址的引用

  和原先访问内存地址一样，段问这些段地址中的内容，也要给出段地址和偏移地址。

* “代码段”、“数据段”、“栈段“完全就是人为的安排

  ```
  assume cs:code, ds:data, ss:stack
  ```

  用这条伪指令，CPU是否就将cs指向code，ds指向data，ss指向stack呢？

  事实并不是这样。

  原先学过，DS是PSP的段地址，这后面256个字节就是PSP中的。也就是段地址加10H后就是cs的段地址。而程序的开头并不是由cs一个人决定的，还有ip也起到作用。

  可以通过改变ip来改变程序的起始位置。

### 三个非常重要的实验

1. ```
   assume cs:code, ds:data, ss:stack
   
   data segment
       dw 0123h, 0456h, 0789h, 0abch, 0defh, 0fedh, 0cbah, 0987
   data ends
   
   stack segment
       dw 0, 0, 0, 0, 0, 0, 0, 0
   stack ends
   
   code segment
   
   start:  mov ax, stack
           mov ss, ax
           mov sp, 16
   
           mov ax, data
           mov ds, ax
   
           push ds:[0]
           push ds:[2]
   
           pop ds:[2]
           pop ds:[0]
   
           mov ax, 4c00h
           int 21h
   
   code ends
   
   end start
   ```

2. ```
   assume cs:code, ds:data, ss:stack
   
   data segment
       dw 0123h, 0456h
   data ends
   
   stack segment
       dw 0, 0
   stack ends
   
   code segment
   
   start:  mov ax, stack
           mov ss, ax
           mov sp, 16
   
           mov ax, data
           mov ds, ax
   
           push ds:[0]
           push ds:[2]
   
           pop ds:[2]
           pop ds:[0]
   
           mov ax, 4c00h
           int 21h
   
   code ends
   
   end start
   ```

3. ```
   assume cs:code, ds:data, ss:stack
   
   code segment
   
   start:  mov ax, stack
           mov ss, ax
           mov sp, 16
   
           mov ax, data
           mov ds, ax
           push ds:[0] 
           push ds:[2] 
           pop ds:[2]
           pop ds:[0]
           
           mov ax, 4c00h
           int 21h
   
   code ends
   
   data segment
       
       dw 0123h, 0456h
   
   data ends
   
   stack segment
   
       dw 0h, 0h
   
   stack ends
   
   end start
   ```

通过这三个实验可以知道，如果段中的数据占N个字节，则程序加载后，该段实际占有的空间为（N/16+1)*16。简单来说，如果有数据就一定是16的倍数大小的内存分配，不够一次就分配16个字节的内存。

而且它们的各个段的内存地址位置也由它们定义的先后来决定。

## 第七章：更灵活的定位内存地址的方法

### and和or指令

> 按位与和按位或，and置0，or置1

```
and ax, 11111110 ;最后一位置0
or ax, 00000001 ;最后一位置1
```

### 关于ASCIIC码

> 一种常用的编码方案，a = 97 = 61H， A = 65 = 41H

### 以字符形式给出数据

在汇编程序中用'……'的方式指明数据是以字符的形式给出的，编译器可以将它们转化为相应的ASCII码

```
assume cs:code, ds:data
data segment
	db 'unIX'
data ends
……
```

显然ASCII码不超过255， 也就是FFH，所以一个字节表示一个字母。

### 大小写转换问题

\'A\'的ASCII码是65，'a'的ASCII码是97。后面的字母又是一个接一个接上的，所以大小写的转换可以用加减32进行计算。

![image-20201113072725239](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201113072725239.png)

但是程序必须判断出当前字母是大写或是小写。还没有学if语句，怎么办。

通过观察它们的二进制数可以得出一个规律，大写字母的第5位二制数都是0，而小写字母的二进制数都是1。

> 如果想把大写转小写，就把第5位置1，可以用or来实现。
>
> 如果想把小写转大写， 就把第5位置0，可以用and来实现。

```
assume cs:code, ds:data

data segment
	
	db 'BaSiC' ;五个字母
	db 'iNfOrMaTiOn' ;十一个字母
	
data ends

code segment

	start:	mov ax, data
			mov ds, ax ;获得data的地址
			mov bx, 0 ;偏移地址清零
			
			mov cx, 5 ;五个字母循环5次
		s:  mov al, [bx]
			and al, 11011111b ;第5位置0，转成大写
			mov [bx], al ;置完送回原位
			inc bx
			loop s
			 
			mov bx, 5
			mov cx, 11
		s0: mov al, [bx]
			or al, 00100000b
			mov [bx], al
			inc bx
			loop s0
			
			mov ax, 4c00h
			int 21h

code ends
end start
```

### [bx + idata]

```
mov ax, [bx + idata]
```

可以用[bx + idata]来指明内存单元，也可以写成下面格式

```
mov ax, [idata + bx]
mov ax, idata[bx]
mov ax, [bx].idata
```

#### 用[bx + idata]的方式进行数组的处理

```
assume cs:code, ds:data

data segment

    db 'BaSiC'
    db 'MinIX'

data ends

code segment

start:  mov ax, data
        mov ds, ax
        mov bx, 0
        mov cx, 5

    s:  mov al, [bx] ; mov al, 0[bx]
        and al, 11011111b
        mov [bx], al ; mov 0[bx], al

        mov al, [5+bx] ; mov al, 5[bx]
        or al, 00100000b
        mov [5+bx], al ; mov 5[bx], al

        inc bx
        loop s

        mov ax, 4c00h
        int 21h

code ends

end start
```

### SI和DI

> source index 源变址寄存器
>
> destination index 目的变址寄存器

这两个寄存器与bx的功能相近，但是不可以分成两个8位寄存器来使用

```
assume cs:code, ds:data

data segment

    db 'welcome to masm!'
    db '................' ;将上面的移到下面

data ends

code segment

    start:  mov ax, data
            mov ds, ax
            mov si, 0

            mov cx, 8

        s:  mov ax, [si]
            mov 16[si], ax
            add si, 2
            loop s

            mov ax, 4c00h
            int 21h

code ends

end start

```

### [bx+si]和[bx+di]

```
mov ax, [bx+si]
mov ax, [bx][si]
```

### [bx+si+idata]和[bx+di+idata]

多种表达，注意idata表示常量 

```
mov ax, [bx + idtata + si]
mov ax, 200[bx][si]
mov ax, [bx][si].200
mov ax, [bx].200[si]
```

### 不同寻址方式的灵活应用

1. 将每个单词的首字母都改成大写

```
assume cs:code, ds:data

data segment

   ;db '0123456789abcdef'
    db '1. file         '
    db '2. edit         '
    db '3. search       '
    db '4. view         '
    db '5. options      '
    db '6. help         '

data ends

code segment

    start:  mov ax, data
            mov ds, ax
            mov bx, 0

            mov cx, 6
        s:  mov al, [bx + 3]
            and al, 11011111b
            mov [bx + 3], al
            add bx, 16
            loop s

            mov ax, 4c00h
            int 21h

code ends

end start

```

2. 将每个单词都改成大写

```
assume cs:code, ds:data, ss:stack

data segment

   ;db '0123456789abcdef'
    db 'ibm             '
    db 'dec             '
    db 'doc             '
    db 'vax             '

data ends

stack segment

stack ends

code segment

    start:  mov ax, data
            mov ds, ax
            mov bx, 0
            
            mov ax, stack
            mov ss, ax
            mov sp, 16

            mov cx, 4
        s0: push cx
            mov si, 0

            mov cx, 3
        s:  mov al, [bx + si]
            and al, 11011111b
            mov [bx + si], al
            inc si

            loop s

            add bx, 16
            pop cx

            loop s0

            mov ax, 4c00h
            int 21h

code ends

end start

```

这里用到了二重循环，用bx来表示首字母开头，用si来表示后面的字母。最终字母由[bx+si]来确定。

重点是cx只有一个，但是两个循环都要靠它，那怎么办。

内层在循环是势必要用到cx，而外层的cx就变成了内层的，只要将外层的cx在开始时保存起来，loop时再放回cx中，让它减1。可以用寄存器来，但是寄存器是有限的，所以最好不要，最后选择了内存，而栈内存正好可以满足。

所以，**用栈来存外层的cx**

C语言等高级语言，也是用栈来存每次调用函数中的内容。 **一般来说，在需要暂存数据的进候，都应该使用栈。**

### 将段中每个单词的前4个字母改成大写

```
assume cs:code, ss:stack, ds:data

data segment

   ;db '0123456789abcdef'
    db '1. display      '
    db '2. brows        ' ;额头
    db '3. replace      ' ;代替
    db '4. modify       ' ;修改

data ends

stack segment

stack ends

code segment

    start:  mov ax, data
            mov ds, ax 
            
            mov ax, stack
            mov ss, ax
            mov sp, 10h ;栈顶别忘了
            
            mov cx, 4

       s0:  push cx
            mov si, 3
            mov cx, 4

        s:  mov al, [bx + si]
            and al, 11011111b
            mov [bx + si], al

            inc si
            loop s

            add bx, 16
            pop cx
            loop s0

            mov ax, 4c00h
            int 21h

code ends

end start

```

## 第八章：数据处理的两个基本问题

> 处理的数据在什么地方
>
> 要处理的数据有多长

定义

* reg为寄存器

* sreg为段寄存器

### bx, si, di, bp

1. 在8086CPU中，这四个寄存器都可以用在[……]中

2. 它们可以单独出现， 或者只能4种组合出现

   1. bx和si
   2. bx和di
   3. bp和si
   4. bp和di

   至于bx和bp，si和di是不可以同时出现的，简单来说，就是不能出现字母一样的。

3. 如果只给了[bp]，那么它的段地址就是ss

### 机器指令处理的数据在什么地方

处理可以分为3类：

1. 读取
2. 写入
3. 计算

在数据的数据也可以在3个地方

1. CPU内部
2. 内存
3. 端口

![image-20201113095856642](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201113095856642.png)

### 汇编语言中数据位置的表达

1. 立即数（idata）
2. 寄存器
3. 段地址（SA）偏移地址（EA）

### 寻址方式

![image-20201113100043228](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201113100043228.png)

### 指令要处理的数据有多长

1. 通过寄存器名指明要处理的数据的尺寸

```
mov ax, [0] ;长度就为2字节，也就是一个字
mov al, [0] ;长度就为1字节
```

2. 如果没有寄存器名，可以用操作符X ptr， X在汇编中可以是word或byte

```
mov word ptr ds:[0], 1 ;指明访问的内存单元是一个字
mov byte ptr [1], 2 ;指明访问的内存单元是一个字节
```

3. 其它方法（push只对字进行操作）

### 寻址方式的综合运用

![image-20201113100610879](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201113100610879.png)

![image-20201113100628816](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201113100628816.png)

如题，题目描述与内存结构如图表示。

现要将其中的内容进行更改：

* 排名改至38位
* 收入增加70
* 产品变成VAX

```
assume cs:code, ds:data

data segment
    
   ;db '0123456789abcdef'
    db 'DEC             ' ;00h
    db 'Ken Oslen       ' ;10h
    dw  137, 0, 0, 0, 0, 0, 0, 0 ;20h
    dw  40, 0, 0, 0, 0, 0, 0, 0 ;30h
    db 'PDP             ' ;40h

data ends

code segment

    start:  mov ax, data
            mov ds, ax

            mov bx, 0
            mov word ptr [bx + 20h],  38
            add word ptr [bx + 30h], 70

            mov si, 0
            mov byte ptr [bx + 40h + si], 'V'
            inc si
            mov byte ptr [bx + 40h + si], 'A'
            inc si
            mov byte ptr [bx + 40h + si], 'X'

            mov ax, 4c00h
            int 21h

code ends

end start
```

这里数字没有用''包起来， 是因为最后表示的是ASCII码，这样不便于加减。

![image-20201113104349953](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201113104349953.png)

![image-20201113104418213](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201113104418213.png)

```
[bx].10h[si]
dec.cp[i]
```

这两条指令是不是很相似？

### div指令

> 除法指令：
>
> 1. 除数：8位或者16位， 在一个reg或者内存单元中
> 2. 被除数：
>    1. 如果除数是8位，被除数就为16位，放在AX中
>    2. 如果除数是16位，被除数就为32位，放在DXAX中，其中DX在高位，AX在低位
>
> 3. 结果：
>    1. 如果除数是8位，AL为商，AH为除数
>    2. 如果除数是16位，AX为商，DX为除数

 ![](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201113112754219.png)

  可以看出，商一定AX中。

编程：利用除法指令计算100001/100

1. 被除数大于65535，不能于ax存放，所以用dxax，100001d = 186a1h

 ```
mov dx, 1h
mov ax, 86a1h
 ```

2. 除数放入bx中

```
mov bx, 100
```

3. 得到结果

```
div bx
```

编程：利用除法指令计算1001/100

```
mov ax, 1001
mov bl, 100
div bl
```

**除数一定要明确是8位还是16位**

### 伪指令dd

> 定义双字型数据

### dup

> 和dd，dw，db一样的伪指令，dup用来进行数据的重复

```
db 3 dup (0)定义了三个字节
db 3 dup (0, 1, 2)定义9个字节，0，1，2，0，1，2，0，1，2
```

### 实验7：寻址方式在结构化数据访问中的应用

![在这里插入图片描述](https://img-blog.csdnimg.cn/202011131758017.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODE1OTkx,size_16,color_FFFFFF,t_70#pic_center)
编程，将data段中的数据按如下格式写入到table段中，并计算21年中的人均收入（取整），结果也按照下面的格式保存在table段中。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20201113180030532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODE1OTkx,size_16,color_FFFFFF,t_70#pic_center)
>提示，可将data段中的数据看成是多个数组，而将table中的数据看成是一个结构型数据的数组，每个结构型数据中包含多个数据项。可用bx定位每个结构型数据，用idtaa定位数据项，用si定位数组项中的每个元素，对于table中的数据的访问可采用[bx].idata和[bx].idata[si]的寻址方式。

可以把年份，总收入，雇员数，人均收入看成一整个结构。
{ '1975'，16， 3， ？}就是一个结构，同理 {1976, 22, 7, ?}也是一个结构。

年份，总收入雇员数，人均收入就是其中的项。
在结构{ '1975'，16， 3， ？}中'1975'，16，3，？都是它的项。

项中也有元素。
'1975'是4个字节，第一个字节是'1'，ASCII码是31h，这个1就是它的元素。

对于data中的数据，用bx来定位每一个结构，用idata来定位项，用si来定位项中的元素。
对于table中的数据，因为没有那么多的寄存器，用bp来定位每一个结构，bp + 偏移地址来表示所有的东西。
```
assume cs:code, ds:data, es:table, ss:stack

data segment

    db '1975','1976','1977','1978','1979','1980','1981','1982','1983'
    db '1984','1985','1986','1987','1988','1989','1990','1991','1992'
    db '1993','1994','1995'
    ; 每一个字符都是一个ASCII码占一个字节，4*21 = 84字节

    ;54h是下面的开始
    dd 16, 22, 382, 1356, 2390, 8000, 16000, 24486, 50065, 97479, 140417, 197514
    dd 345980, 590287, 803530, 1183000, 1843000, 2759000, 3753000, 4649000, 5937000
    ; 21个双字, 4*21 = 84字节

    ;54h + 54h是下面的开始
    dw 3, 7, 9, 13, 28, 38, 130, 220, 476, 778, 1001, 1442, 2258, 2793, 4037, 5635, 8226
    dw 11542, 14430, 15257, 17800
    ; 21个字, 42字节
    ;54h+54h+2ah是后面的开始

data ends

table segment

    db 21 dup('year summ ne ?? ')

table ends

stack segment

stack ends

code segment

    start:  mov ax, data
            mov ds, ax
            mov bx, 0 ;定位data结构型数据
            mov si, 0 ;定位数据项中的每个元素

            mov ax, table
            mov es, ax
            mov bp, 0 ;定位table结构型数据

            mov ax, stack
            mov ss, ax
            mov sp, 2

            mov cx, 21
       s:   mov ax, ds:[bx].0[si] ;ds + 0 + si定位，找到年份的低字节
            mov es:[bp], ax ;bp定位，低字节拷入
            mov ax, ds:[bx].0[si + 2] ;高字节
            mov es:[bp + 2], ax

            mov ax, ds:[bx].84[si] 
            mov es:[bp + 5], ax ;拷入收入低字节
            mov dx, ds:[bx].84[si + 2]
            mov es:[bp + 7], dx ;拷入收入高字节

            push cx ;因为被除数是4字节，所以要用dx存高位，ax存低位，所有16位寄存器（ax,bx,cx,dx,si,di)都在使用，只能用栈暂存了
        
            mov cx, ds:[84 + 84 + di] ;84+84是雇员的地址，也就3，7，9……中3所在的位置，循环一次加一个字，也就是二个字节
            mov es:[bp + 0ah], cx

            div cx
            pop cx

            mov es:[bp + 0dh], ax ;div结果在ax中

            add di, 2 ;雇员地址，一次加2个字节
            add bx, 4 ;bx是年份，一次加4个字节
            add bp, 16 ;bp是table年份的首地址，一次加10h

            loop s

            mov ax, 4c00h
            int 21h
code ends

end start
```
![ ](https://img-blog.csdnimg.cn/20201113213554393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODE1OTkx,size_16,color_FFFFFF,t_70#pic_center)

 

## 第9章：转移指令的原理

> 可以修改IP，或同时修改CS和IP的指令统称为转移指令

![image-20201114125348792](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201114125348792.png)

### 操作符offset

> 取得标号的偏移地址

### jmp指令

给出两种信息：

1. 转移的目的地址
2. 转移的距离(段间转移、段内短转移、段内近转移)

### 依据位移进行转移的jmp指令

```
jmp short 标号
```

这条语句执行：会将IP加上一个8位位移

1. 8位位移=标号处的地址-jmp指令后的第一个字节的地址
2. short表明是8位位移
3. 范围应该是-128~127，用补码表示
4. 8位位移由编译器在编译时算出

相似的是

```
jmp near ptr 标号
```

不过它是16位的位移

### 转移的目的地址在指令中的jmp指令

前面的jmp指令，其对应的机器指令中并没有转移的目的地址。而是相对于当前IP的转移。

```
jmp far ptr 标号
```

CS = 标号所在的段地址

IP = 标号所在的偏移地址

### 转移地址在寄存器中的jmp指令

```
格式：jmp 16位reg
功能：IP= 16位reg
```

### 转移地址在内存中的jmp指令

1. ```
   jmp word ptr 内存单元地址（段内转移）
   ```

   内存单元中的是偏移地址

2. ```
   jmp dword ptr 内存单元地址（段间转移）
   ```

   内存单元中高地址是目的段地址，低地址是转移的目的偏移地址

   CS = 内存单元+2

   IP = 内存单元

### jcxz指令

> 有条件转移指令，短转移，在对应机器码中包含转移的位移。范围-128~127

```
指令格式：jcxz 标号 （如果cx = 0，转移到标号处执行）
操作：当cx为0时， IP = IP + 8位位移
```

### loop指令

> 循环指令，短转移。范围-128~127

```
指令格式：loop 标号（cx = cx - 1，cx不为0，转到标号）
操作：cx = cx - 1，如果cx不为0，IP = IP + 8位位移
```

### 根据位移进行转移的意义

> 方便程序段在内存中浮动装配，在内存中的不同位置都可以执行。

### 编译器对转移位移超界的检测

> 转移范围-128~127，超了程序会报错。

### 实验8 分析一个奇怪的程序

分析下面的程序，在运行前思考：这个程序可以正确返回吗？

运行后再思考：为什么是这种结果

通过这个程序加深对相关内容的理解。

```
assume cs:code

code segment

            mov ax, 4c00h
            int 21h

    start:  mov ax, 0
        s:  nop
            nop

            mov di, offset s
            mov si, offset s2
            mov ax, cs:[si]
            mov cs:[di], ax

       s0:  jmp short s

       s1:  mov ax, 0
            int 21h
            mov ax, 0

       s2:  jmp short s1
            nop

code ends

end start
```

经过运行，发现过程是这样的：

```
1. mov ax, 0
2. s: nop
	  nop
3. mov di, offset s
   mov si, offset s2
   mov ax, cs:[si]
   mov cs:[di], ax ;将s2的代码给了s
4. jmp short s ;跳到s
5. jmp short s1 ;在s的位置执行了s2的命令，向前10个字节，一下子跳到 mov ax 4c00h去了
6. mov ax, 4c00h
```

为什么会出现这种情况？是因为在编译时，jmp short 命令编译器已经确定好了位移的长度。

![image-20201114150041463](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201114150041463.png)

第一个jmp对应

```
s0:  jmp short s
```

根据机器码可知EBF0，它的位移是补码F0，也就是11110000，最高位是1，所以是负数，其正数应该是00010000h= 16。

> 负数的补码和正数的补码相互转换——从左到右复制，复制完一个1， 后面全部取反即可

所以为-16。可以验证一下，jmp后一位为0018h，s为0008h，0008h - 0018h = 8 - 24 = -16。

第二个jmp对应

```
s2:  jmp short s1
```

机器码F6，也就是-10，验证，0018h - 0022h = 24 - 34 = -10，本身这个-10，是从s1到s2的。

```
mov di, offset s
mov si, offset s2
mov ax, cs:[si]
mov cs:[di], ax
```

这段代码将s2给了s。等到跳到s后，就执行了原先那个s2的命令。

```
jmp short s1 ;向前10字节
```

在s处IP=8，减掉10就是0（不能小于0）。

![image-20201114151926536](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201114151926536.png)

## 第10章CALL和RET指令

### ret和retf

> ret用栈中数据修改IP，近转移
>
> retf用栈中数据修改CS和IP，远转移

用汇编语法来解释：

```
reg = pop IP
regf = pop IP pop CS
```

### call指令

> 1. 将当前IP或CS和IP压栈
> 2. 转移 

**要注意的是：call指令在执行时，当前IP已经指向了它的后一个的位置**

![image-20201115095518433](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201115095518433.png)

### 依据位移进行转移的call指令

> call 标号

```
push IP
jmp near ptr 标号（16位寄存器）
```

### 转移的目的地址在指令中的call指令

> call far ptr 标号 （段间转移）

```
push CS
push IP
jmp far ptr 标号
```

### 转移地址在寄存器中的call指令

> call 16位寄存器

```
push IP
jmp 16位reg
```

寄存器和要push栈中的IP没有关系，它只是保存要转移到的地址。要存到栈中的IP还是原来的call地址的后面一位。

### 转移地址在内存中的call指令

* call word ptr 内存单元地址

```
push IP
jmp word ptr 内存单元地址
```

* call dword ptr 内存单元地址

```
push CS
push IP
jmp dword ptr 内存单元地址
```

不难看出call指令的目地是保存下一步要执行的地址到栈中，然后跳到别的位置去。显然这与高级语言中的调用函数密不可分。

### 检测点：10.5

![image-20201115111146961](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201115111146961.png)

```
assume cs:code, ss:stack

stack segment

    dw 8 dup (0)

stack ends

code segment

    start:  mov ax, stack
            mov ss, ax
            mov sp, 16

            mov ds, ax ;ds与ss一样
            mov ax, 0
            call word ptr ds:[0Eh] 
;1. 先将IP入栈，也就是下一条语句inc ax地址入栈，入栈位置就在ss:[0eh]。
;2. 再跳到ss:[oeh]地址位置，就是到inc ax了，和正常执行一样

            inc ax
            inc ax
            inc ax

            mov ax, 4c00h
            int 21h

code ends

end start
```

下面这段代码完成后AX，BX分别是多少?

```
assume cs:code, ss:stack

stack segment

    dw 8 dup (0)

stack ends

code segment

    start:  mov ax, stack
            mov ss, ax
            mov sp, 16

            mov word ptr ss:[0], offset s
;将s标号的位置送入栈0位置，注意现在的栈顶在ss:[10h]，严格来说ss:[0]不在栈中

            mov ss:[2], cs
;将cs入栈2
            call dword ptr ss:[0] 
;1. 先将CS入栈，这个CS是下一条nop的CS，ss:[0eh] = cs(nop的段地址是cs)
;2. 再将IP入栈，也就是下一条语句nop的偏移地址入栈 ss:[0ch] = nop偏移地址
;3. 跳到CS = ss:[2], IP = ss:[0]处，也就是 CS:s处 jmp dword ptr 内存单元地址
            nop
            
       s:   mov ax, offset s
            sub ax, ss:[0ch]
;ax - ss:[0ch] = s地址-nop的地址 = 1

            mov bx, cs
            sub bx, ss:[0eh]
;bx - ss:[0eh] = cs - cs = 0

            mov ax, 4c00h
            int 21h 

code ends

end start
```

![image-20201115132726794](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201115132726794.png)

### call和ret的配合使用

> 显然call和ret可以组合使用，实现子程序的机制。

```
assume cs:code
code segment
	main:	:
			:
			call sub1
			:
			:
			mov ax, 4c00h
			int 21h
	sub:	:
			:
			call sub2
			:
			:
			ret
	sub2:	:
			:
			ret
code ends
end main
```

### mul指令

> mul是乘法指令

1. 乘数
   1. 同是8位
   2. 同是16位

2. 结果
   1. 8位乘法的结果放在ax中
   2. 16位乘法结果高位放在dx中，低位放在ax中

![image-20201116181217533](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201116181217533.png)

```
mul reg
mul 内存单元
```

例如：

```
mul byte ptr ds:[0]
mul word ptr ds:[0]
```

### 模块化程序设计

> 将复杂的现实问题转化成相互联系，不同层次的子问题。

### 参数和结果传递的问题

子程序的三个重要信息

1. 程序的功能
2. 参数
3. 结果（返回值）

那么这里我们应该将参数和结果放在什么位置？

> 用寄存器来存储参数和结果是最常用的方法

明确程序调用的参数传递问题：

调用者将参数送入参数寄存器，从结果寄存器取得返回值；子程序从参数寄存器取得参数，将返回值送入到结果寄存器。

### 批量数据传递

如果子程序需要多个参数，那么就可以用到内存中的地址。

### 用栈传递参数

结合c语言的函数调用，看一下栈传递参数的思想：

> 将参数全部压入栈，然后将IP压入，此是栈顶是IP，再压入一个存放返回值的寄存器。函数体结束后，先弹出返回值，再弹出IP，将栈清空即可。

![image-20201116192641899](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201116192641899.png)

![image-20201116192544329](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201116192544329.png)

### 寄存器冲突问题

如果子程序调用时，寄存器不够用，可以用栈来保存。

![image-20201116193125360](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201116193125360.png)

### 实验10：编写子程序

#### 1. 显示字符串

![image-20201117135239550](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201117135239550.png)

```
assume cs:code, ds:data, ss:stack

data segment

    db 'Welcome to masm!', 0

data ends

stack segment

    db 16 dup (0)

stack ends

code segment

    start:  mov dh, 8
            mov dl, 3
            mov cl, 2

            mov ax, data
            mov ds, ax
            mov si, 0

            mov ax, stack
            mov ss, ax
            mov sp, 10h

            call show_str

            mov ax, 4c00h
            int 21h

 show_str:  push cx
            push dx

;列位置计算，放到di中
            mov al, 2
            mul dl
            sub ax, 2
            mov di, ax

;行位置计算，最后放到es中
            mov al, 10
            mul dh
            mov dx, ax
            mov ax, 1800h
            add ax, dx
            mov es, ax
            
;cx后面要用，把它给bl
            mov bp, 0
            mov bl, cl

   invoke:  mov ch, 0
            mov cl, ds:[si]
            jcxz ok
            mov byte ptr es:[bp][di], cl
            inc bp
            mov byte ptr es:[bp][di], bl
            inc bp
            inc si

            jmp short invoke

       ok:  pop dx
            pop cx
            ret 

code ends

end start
```

![image-20201117135323240](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201117135323240.png)

#### 2. 解决除法溢出问题

![image-20201117153136966](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201117153136966.png)

#### 3. 数值显示

![image-20201117155139520](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201117155139520.png)

```
assume cs:code, ds:data, ss:stack

data segment

    db 10 dup(0)

data ends

stack segment

    db 16 dup(0)

stack ends

code segment

    start:  
            mov ax, 12666
            mov bx, data
            mov ds, bx

            mov si, 0
            call dtoc

            mov dh, 8
            mov dl, 3
            mov cl, 2
            call show_str

            mov ax, 4c00h
            int 21h

     dtoc:  
            push ax
            push bx

            mov bx, 10

            mov bp, 0
            push bp
       hh:  mov dx, 0
            div bx

            mov cx, dx ;余数
            jcxz ll

            push cx ;将有效的cx全入栈
            jmp short hh

       ll:  pop cx ;将cx出栈
            jcxz kk
            add cx, 30h
            mov byte ptr ds:[si], cl
            inc si
            jmp short ll
            
       kk:  
            pop bx
            pop ax
            ret

 show_str:  push cx
            push dx

;列位置计算，放到di中
            mov al, 2
            mul dl
            sub ax, 2
            mov di, ax

;行位置计算，最后放到es中
            mov al, 10
            mul dh
            mov dx, ax
            mov ax, 1800h
            add ax, dx
            mov es, ax
            
;cx后面要用，把它给bl
            mov bp, 0
            mov bl, cl
            mov si, 0

   invoke:  mov ch, 0
            mov cl, ds:[si]
            jcxz ok
            mov byte ptr es:[bp][di], cl
            inc bp
            mov byte ptr es:[bp][di], bl
            inc bp
            inc si

            jmp short invoke

       ok:  pop dx
            pop cx
            ret 

code ends

end start
```

 ## 第11章：标志寄存器

标志寄存器的作用：

1. 用来存储相关指令的某些执行结果
2. 用来为CPU执行相关指令提供行为依据
3. 用来控制CPU的相关工作方式 

8086CPU的标志寄存器有16位，其中存储的信息通常被称为程序状态字(PSW)，前面已经学过

```asm
ax, bx, cx, dx, si, di, bp, sp, IP, cs, ss, ds, es
```

13个寄存器，下面是最后一个寄存器flag。

![image-20201119175710305](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201119175710305.png)

其中每一位都有其相应的含义：

### ZF标志（zero flag)

零标志位：如果指令执行后，结果为0，那它就为1，否则为0

> 一般都是逻辑或算术运算的指令才会对其有影响，push、mov、pop移动指令对其没有影响

### PF标志（Parity flag)

奇偶标志位：一个数的二进制数表示有偶数个1，它就为1，否则为0

### SF标志（Symbol flag）

符号标志位：如是这个数是负数，它就为1，非负就为0

### CF标志 （Carry flag）

进位标志位：**无符号数**运算，如果存在相高位进位或者借位就为1，否则为0。

### OF标志（Over flag）

溢出标志位：对于n位寄存器，**有符号**运算，结果超出了它的表示范围为就是溢出。它就为1，否则为0。对于两个异号的有符号来说，是不同产生溢出的。

对于CPU来说，有符号数，用最高位的进位和次高位的进位的异或来表示OF。

例1：

```
mov al, 0f0h
add al, 88h
```

人脑来算：（注意这里只考虑有符号数）-16 + (-120) = -136 < -128溢出

CPU来算：

```
	11110000
+	10001000
__1____________
  1	01111000
  最高位进位1，次高位进位0

```

所以1 XOR 0 = 1溢出。

例2：

```
mov al, 0fh
mov al, 78h
```

人脑来算：-16 + 136 = 120 < 127不溢出

CPU来算：

```
	11110000
	01111000
+
__1_1________
  1 01101000
  最高位进1，次高位也进1
```

所以1 X OR 1 = 0 没有溢出。

### adc指令

带进位的加法指令：

> 与add命令相同，只不过是带进位的加法，也就是说，它会加上CF上面的进位。

用这个指令就可以实现多位数据的运算操作。

![image-20201119192646084](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201119192646084.png)

128位数据 = 16字节 = 16个Byte型数据

```c
assume cs:code, ds:data, ss:stack

data segment

    db 11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h,11h
    db 88h,88h,88h,88h,88h,88h,88h,88h,88h,88h,88h,88h,88h,88h,88h,88h
    
data ends

stack segment

stack ends

code segment

    start:  mov ax, data
            mov ds, ax

            mov di, 16
            mov cx, 8

            mov ax, stack
            mov ss, ax

            call add128

            mov ax, 4c00h
            int 21h

   add128:  push cx
            push ax
            push si
            push di

            sub ax, ax

       s:   mov ax, [si]
            adc ax, [di]
            mov [si], ax

            inc si 
            inc si 
            inc di
            inc di
            loop s

            pop di
            pop si
            pop ax
            pop cx
            ret

code ends

end start
```

为什么不写

```
add si, 2
add di, 2
```

因为这样可能会影响到CF标志位。如果是inc操作就不会。

### sbb指令

带借位的减法指令：

> 与adc指令相同，不过是用于减法。

### cmp指令

比较指令：

```
cmp 操作对象1, 操作对象2
```

> 原理就是减法，只是不保存结果。也就是说与sub不同的是操作对象1的值没有改变。

比较的结果可以通过各标志位看出来。

```
mov ax, 8
mov bx, 3
cmp ax, bx
```

8 - 3 = 5

```
zf = 0, pf = 1, sf = 0, cf = 0, of = 0
```

显然，对于无符号数，很轻易的就可以看出ax与bx的大小关系。

但是，对于有符号数而言，要考虑的就是溢出标志位和进给标志位了。

```
cmp ah, bh 对于ah和bh而言，你期望的是它们相减会得到一个数，这个数可能不在可以表示的范围内，所以就溢出了，导致最终结果与实际结果相反。
例如：
mov ah, 22h
mov bh, 0a0h
sub ah, bh
期望的结果：34-(-96) = 130 因为已经超过了127，所以溢出了
实际的结果：82h = -126
```

1. 如果sf = 1，而of = 0

   of为0，也就是没有溢出，你期望的结果 = 实际的结果

   sf = 1，ah - bh < 0，所以ah < bh

2. 如果sf = 1， 而of = 1

   of为1，也就是溢出了，你期望的结果和实际的结果相反

   sf = 1实际的结果为负，你期望的结果为正，就是说本身而言ah > bh

3. 如果sf = 0， 而of = 0

   of为0，没有溢出，实际与期望相同。

   sf = 0，ah >= bh

4. 如果sf = 0， 而of = 1

   of为1，有溢出，实际与期望相反。

   sf = 0为非负，相反为负数，所以ah < bh

### 检测比较结果的条件转移指令

前面学过的jcxz就是一个条件转移指令。

**所有的条件转移指令的转移位移都是[-128, 127]**

像call和ret一样，条件转移指令与cmp连用可以实现高级语言中的if语句

![image-20201119202656151](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201119202656151.png)

#### 1. 编程，统计data段中数值为8的字节的个数，用ax保存统计结果

用否定写：

```
assume cs:code, ds:data, ss:stack

data segment

    db 8, 11, 8, 1, 8, 5, 63, 38
    
data ends

stack segment

stack ends

code segment

    start:  
            mov ax, data
            mov ds, ax
            mov si, 0
            mov cx, 8

            mov ax, 0
        s:  
            mov bl, [si]
            cmp bl, 8
            jne a
            inc ax
        a:  
            inc si
            loop s

            mov ax, 4c00h
            int 21h

code ends

end start

```

用肯定写：

```
assume cs:code, ds:data, ss:stack

data segment

    db 8, 11, 8, 1, 8, 5, 63, 38
    
data ends

stack segment

stack ends

code segment

    start:  
            mov ax, data
            mov ds, ax
            mov si, 0
            mov cx, 8

            mov ax, 0
        s:  
            mov bl, [si]
            cmp bl, 8
            je a
            jmp short o
        a:  
            inc ax
      o:
            inc si
            loop s

            mov ax, 4c00h
            int 21h

code ends

end start

```

注意要考虑cx为0后程序loop跳出也会继续向下执行。要把loop s放在最后。

### DF（Direction flag）标志和串传送指令

![image-20201120113502406](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201120113502406.png)

![image-20201120113527332](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201120113527332.png)

当然也可以一次传送一个字：

```
movsw
```

那si和di一次就是加（减）两个了。

显然这种指令多用于循环中，循环多用cx来记录终止。

```
cld df置0
std df置1
rep movsw
```

### pushf和popf

与push和pop的功能相同。只不过对于寄存器

![image-20201119175710305](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201119175710305.png)

就是这家伙。

例题：执行完后ax = ？

```
mov ax, 0
push ax
popf ;flag = 0
mov ax, 0fff0h 
add ax, 0010h ; fff0 + 10 = 1 0000 CF = 1, PF = 1, ZF = 1, OF = 0 所以flag = 0000 0000 0100 0101 = 0045h
pushf ;flag 入栈
pop ax ; flag出栈给ax = 0045h
adn al, 11000101b ;al = 45h
and ah, 00001000b ;ah =00h
```

综上ax = 0045h

### 标志寄存器在Debug中的表示

![image-20201120114713347](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201120114713347.png)

## 第12章：内中断

> 任何一个通用CPU都具备一种能力，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。
>
> 这种特殊的信息，我们称其为：中断信息

### 内中断的产生

8086CPU以下几种情况会产生中断：

1. 除法错误，中断类型码：0
2. 单步执行， 中断类型码：1
3. 执行into指令， 中断类型码：4
4. 执行int指令， int n 指令中的n为字节型立即数，是提供给CPU的中断类型码。



中断信息中必须包含识别来源的编码。8086CPU用中断类型码的数据来标识中断信息的来源。

**中断类型码为一个字节型数据，可以表示256种中断信息的来源。**

中断信息的来源，简称为中断源。上面就是4种中断源。

### 中断处理程序 

> CPU在收到中断信息后，就应该转去执行该中断信息的处理程序。但是如何定位这个中断处理程序呢？

### 中断向量表

> 中断向量，就是中断处理程序的入口地址。
>
> 中断向量表：就是中断处理程序 入口地址的列表

中断向量表在内存中存放，对于8086pc机，中断向量表指定放在内存地址0处，从0000:0000到0000:03ff的1024个单堍存放着中断向量表。

> N号中断源对应的中断处理程序入口的偏移地址的内存单元地址：4N
>
> N号中断源对应的中断处理程序入口的段地址的内存单元地址：4N + 2

**中断类型码作为中断向量表中的表项号来查找表项，再当相应的程序入口去**

在中断向量表中，一个表项中两个字：高地址字存放段地址，低地址字存放偏移地址。

### 中断过程

1. （从中断信息中）取得中断类型码
2. 标志寄存器的值入栈
3. 设置标志寄存器的第8位TF和第9位IF的值为0
4. CS的内容入栈
5. IP的内容出栈
6. 从内存地址为中断类型码*4和中断类型码\*+2的两个字单元中读取中断处理程序的入口地址设置CS和IP

### 中断处理程序和iret指令

中断处理程序应该在内存中，而中断处理程序的入口地址应该在中断向量表表项中。

中断程序与子程序有点像：

1. 保存用到的寄存器
2. 处理中断
3. 恢复用到的寄存器
4. 用iret指令返回

```
iret可以理解为
pop ip
pop cs
popf
```

### 编程处理0号中断

重新定义0号中断的中断处理程序：

1. 向量表中断源对应中断处理程序
2. 中断处理程序写在哪？

```
assume cs:code

code segment

    start:  mov ax, cs
            mov ds, ax
            mov si, offset do0

            mov ax, 0
            mov es, ax
            mov di, 200h
            
            mov cx, offset do0end-offset do0
            cld
            rep movsb

            mov ax, 0
            mov es, ax
            mov word ptr es:[0*4], 200h
            mov word ptr es:[0*4 + 2], 0

            mov ax, 4c00h
            int 21h

      do0:  
            jmp short do0start
            db "overflow!"

    do0start:        
                mov ax, cs
                mov ds, ax
                mov si, 202

                mov ax, 0b800h
                mov es, ax
                mov di, 0
                mov cx, 9
            s:  
                mov al, [si]
                mov es:[di], al
                inc si
                add di, 2
                loop s

                mov ax, 4c00h
                int 21h

   do0end:  
            nop

code ends

end start
```

中断后：

1. 程序将do0拷到内存0:200
2. 将do0的入口地址放入向量表中
3. 运行do0打印字符串

### 单步中断

> CPU执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，中断类型码为1

1. 取中断类型码1
2. 标志寄存器入栈，TF、IF设置为0
3. CS、IP入栈
4. IP = 1*4，CS = 1\*4+2

### 响应中断的特殊情况

> 有些情况下，CPU执行完当前指令也不会响应中断

比如栈的操作应该连续完成，也就是设置SS与SP，保证ss:ip 指向正确的栈顶。

所以在编码时应该要将两者放在一起。下面是错误写法。

```
mov ax, 1000h
mov ss, ax
mov ax, 0
mov sp, 0
```

## 第13章：int指令

CPU的中断可以来自内部和外部。

int就是一种重要的内中断

### int指令

```
int n
```

1. 取中断类型码n
2. 标志寄存器入栈，TF、IF设置为0
3. CS、IP入栈
4. IP = 1*n，CS = 1\*n+2

### 编写供应用程序调用的中断例程

#### 1. 求一个数的平方乘2

```
assume cs:code

code segment
    start:  mov ax, 0
            mov es, ax
            mov di, 200h

            mov ax, cs
            mov ds, ax
            mov si, offset sqr

            mov cx, offset sqrend-offset sqr
            cld
            rep movsb

            mov ax, 0
            mov es, ax
            mov word ptr es:[7ch*4], 200h
            mov word ptr es:[7ch*4+2], 0 

            mov ax, 3456
            int 7ch
            add ax, ax
            adc dx, dx

            mov ax, 4c00h
            int 21h

      sqr:  mul ax
            iret

   sqrend:  nop


code ends

end start
```

将求平方的程序写在0:200内存处，再将程序的入口地址放在7ch表项中，使其成为中断7ch的中断例程。

#### 2.将内存地址上的字母小写改大写

```
assume cs:code, ds:data

data segment

    db 'conversation',0

data ends

code segment

    start:  
            mov ax, 0
            mov es, ax
            mov di, 200h

            mov ax, cs
            mov ds, ax
            mov si, offset interrupt

            mov cx, offset interruptend - offset interrupt
            cld
            rep movsb

            mov ax, 0
            mov es, ax
            mov word ptr es:[7ch*4], 200h
            mov word ptr es:[7ch*4+2], 0

            mov ax, data
            mov ds, ax
            mov si, 0
            int 7ch

            mov ax, 4c00h
            int 21h

interrupt: 
            push cx
            push si
        s:  
            mov cl, [si]
            mov ch, 0
            jcxz ok
            and byte ptr [si], 11011111b
            inc si
            jmp short s

       ok:
            pop si
            pop cx

            iret

interruptend: 
            nop

code ends

end start 

```

### 对int、iret和栈的深入理解

#### 用7ch完成loop指令的功能

```
assume cs:code

code segment

    start:
            mov ax, 0
            mov es, ax
            mov di, 200h

            mov ax, cs
            mov ds, ax
            mov si, offset lp

            mov cx, offset lpend - offset lp

            cld
            rep movsb

            mov ax, 0
            mov es, ax
            mov word ptr es:[7ch*4], 200h
            mov word ptr es:[7ch*4 + 2], 0

            mov ax, 1800h
            mov es, ax
            mov di, 0
            mov bx, offset s - offset se
            mov cx, 80
        s:  
            mov byte ptr es:[di], '!'
            inc di
            int 7ch
            
        se: nop
        mov ax, 4c00h
        int 21h

       lp: 
            mov bp, sp
            dec cx
            jcxz lpret
            add ss:[bp], bx 

    lpret:
            iret

    lpend:
            nop
            
code ends

end start
```

可以推测：可以转移的最大位移应该bx的最大值：FFFFH

#### 用7ch完成jmp near ptr s指令

```
assume cs:code

code segment

    start:
            mov ax, 0
            mov es, ax
            mov di, 200h

            mov ax, cs
            mov ds, ax
            mov si, offset jps

            mov cx, offset jpend - offset jps

            cld
            rep movsb

            mov ax, 0
            mov es, ax
            mov word ptr es:[7ch*4], 200h
            mov word ptr es:[7ch*4+2], 0

            mov bx, offset e - offset s
            int 7ch

        s:  nop

            mov ax, 3
            add ax, ax
            add ax, ax
            add ax, ax
            add ax, ax
            add ax, ax
            add ax, ax

        e:  nop
            mov ax, 4c00h
            int 21h

       jps:  
            push bp

            mov bp, sp
            add [bp+2], bx

    jlret:
            pop bp
            iret

    jpend:  nop


code ends
end start
```

### BIOS和DOS所提供的中断例程

在系统板的ROM中存放着一套程序：BIOS

1. 硬件系统的检测和初始化程序
2. 外部中断和内部中断例程
3. 用于对硬件设备进行I/O操作的中断例程
4. 其他和硬件系统相关的中断例程

操作系统DOS也提供了中断例程。DOS就是操作系统向程序员提供的编程资源。

### BIOS和DOS的安装过程

![image-20201123210120972](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201123210120972.png)

### BIOS中断例程应用

![image-20201123211439650](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201123211439650.png) 

![image-20201123211454711](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201123211454711.png) 

![image-20201123211512140](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201123211512140.png)

### DOS中断例程应用

int 21h中断例程是DOS提供的中断例程，其中包含了DOS提供给程序员在编程时调用的子程序。

```
mov ah, 4ch
mov al, 0 ;返回值 
int 21h
```

ah = 4ch表示调用第21h号中断例程的4ch号子程序，功能为程序返回，可以提供返回值作为参数。这里的返回值就是0。

```
assume cs:code, ds:data

data segment

    db 'Welcome to masm!', '$'

data ends

code segment

    start:
            mov ah, 2 ;置光标
            mov bh, 0
            mov dh, 5
            mov dl, 12
            int 10h
            
            mov ax, data
            mov ds, ax
            mov dx, 0
            mov ah, 9 ;在光标处显示字符
            int 21h

            mov ax, 4c00h
            int 21h

code ends
end start
```

### 实验13：编写、应用中断例程

1. 编写并安将int 7ch中断例程，功能为显示一个用0结束的字符串，中断例程安将在0:200处。

![image-20201124094518851](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201124094518851.png)

```
assume cs:code

data segment

    db "Welcome to masm!", 0

data ends

code segment

    start:
            mov ax, 0
            mov es, ax
            mov di, 200h

            mov ax, cs
            mov ds, ax
            mov si, offset interr
            mov cx, offset endi - offset interr

            cld
            rep movsb ;安装到内存0:200

            mov word ptr es:[7ch*4], 200h
            mov word ptr es:[7ch*4+2], 0 ;写放向量表

            mov dh, 10
            mov dl, 10
            mov cl, 2
            mov ax, data
            mov ds, ax
            mov si, 0
            int 7ch
            
            mov ax, 4c00h
            int 21h

    interr:
            mov ax, 0b800h
            mov es, ax
            mov bl, cl

            mov al, 160
            mul dh

            mov dh, 0
            add ax, dx
            add ax, dx
            mov di, ax

        s:  
            mov cl, [si]
            mov ch, 0
            jcxz ok

            mov byte ptr es:[di], cl
            inc di
            mov byte ptr es:[di], bl
            inc di
            inc si
            jmp short s

        ok: 
        	iret
            
      endi:
            nop
code ends

end start
```

## 第14章：端口

> 各种存储器都和CPU的三大总线相连，CPU在操控它们的时候，都把它们当作内存来看待。把它们总地看做一个由若干存储单元组成的逻辑存储器，这个逻辑存储器我们称其为内存地址空间。

和CPU相连的芯片除各种存储器外，还有以下三种：

1. 各种接口卡上的接口芯片，它们控制接口卡进行工作
2. 主板上的接口芯片，CPU通过它们对部分外设进行访问
3. 其他芯片，用来存储相关系统信息，或进行相关的输入输出处理

在这些芯片中，都 有一组可以由CPU读写的寄存器，在物理上，它们可能处于不同的芯片中，但是在以下两点上相同：

1. 都和CPU的总线相连，
2. CPU对它们进行或写的进候都通过控制线向它们所在的芯片发出端口读写命令

从CPU角度来说，CPU把这些寄存器都当作端口，对它们进行了统一编址，建立了一个统一的地址空间。每一个端口在地址空间中都有一个地址。

CPU可以直接读写以下3个地方的数据：

1. CPU内部的寄存器
2. 内存单元
3. 端口

### 端口的读写

> 端口和内存地址一样，都通过地址总线来传送。在PC系统中，CPU最多可以定位64KB个不同的端口。则端口的地址范围为0~65535

* 读端口

  ```
  in al, 60h
  ```

  从60h号端口读入一个字节

* 写端口

  ```
  out 60h, al
  ```

  往60h号端口写入一个字节

  可见这两个指令与其它的指令一样，将最终的目地的紧跟在指令的后面。比如读，读到哪里？读到al。写，写到哪里？写到60h。

  **in和out指令只能用al和ax来操作，前者8位，后者16位。**

### CMOS RAM芯片

![image-20201125102153193](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201125102153193.png)

### 检测点14.1

1. 编程，读取CMOS RAM的2号单元的内容。

```
mov al, 2
out 70h, al ;将2号单元写入到70h中，70h存放的就是2号单元的地址
in al, 71h ;读取70h中存放的地址（2号单元）上的内容到al中
```

2. 编程，向CMOS RAM的2号单元写入0

```
mov al, 2
out 70h, al ;通过地址找到2号单元
mov al, 0 ;al置0
out 71h, al ;把al写入到2号单元中
```

70h放你要访问的CMOS ROM的地址，71h操作你放在70h中地址上的数据。

### shl和shr指令

> shl左移
>
> shr右移
>
> 位移最后移出的一位写入CF中，低位用0补充

```
mov al, 01001000b
shl al, 1 ;左移一位
```

如果移动的位数大于1，将1换成cl。

```
mov al, 01010001b
mov cl, 3
shl al, cl
```

执行后：al  = 10001000b

### 检测14.2

编程，用加法和移位指令计算ax = ax * 10

```
mov ax,16
mov bx, ax
shl bx, 1
mov cl, 3
shl ax, cl
add ax, bx
```

### CMOS RAM中存储的时间信息

![image-20201125181251346](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201125181251346.png)

```
assume cs:code

data segment        
    db '/','/',' ',':',':'
data ends

code segment

date: db 9, 8, 7, 4, 2, 0

    start:
            mov cx, offset start - offset date ;共6个内容

            mov bx, offset date
            mov di, 160*14

            mov si, 0
            mov ax, data 
            mov ds, ax
        s:  
            mov al, cs:[bx]
            call invoke
            inc bx
            loop s
            
            mov ax, 4c00h
            int 21h
    invoke:
            push cx
            push ax
            push bx

            out 70h, al
            in al, 71h

            mov ah, al ;将8位值给ah
            mov cl, 4 
            shr ah, cl ;右移4位
            and al, 00001111b ;高位置0

            add ah, 30h
            add al, 30h ;加上48（30h）就是对应的数字的ASCII码

            mov bx, 0b800h
            mov es, bx
            mov byte ptr es:[di], ah ;十位
            inc di
            mov byte ptr es:[di], 02 ;颜色
            inc di
            mov byte ptr es:[di], al ;个位
            inc di
            mov byte ptr es:[di], 02
            inc di
;填符号
            mov dl, ds:[si]
            mov byte ptr es:[di], dl
            inc di
            mov byte ptr es:[di], 02
            inc di

            inc si

            pop bx
            pop ax
            pop cx
            ret

code ends
end start
```

重点BCD码的转换：

两个BCD码是一个字节，高位是高位数据，低位是低位数据。比如：不超过两位的十进制数，用BCD码来表示十位用高四位，个位用低四位。

```
mov ah, al
mov cl, 4
shr ah, cl ;执行完al的高四位在ah的低四位
and al, 00001111b
```







```
assume cs:code

stack segment
    db 128 dup(0)
stack ends

data segment
    dw 0, 0
data ends

code segment

    start:
            mov ax, stack
            mov ss, ax
            mov sp, 128

            mov ax, data
            mov ds, ax
            
            mov ax, 0
            mov es, ax

            push es:[9*4]
            pop ds:[0]
            push es:[9*4+2]
            pop ds:[2] ;保存9号中断

            mov word ptr es:[9*4], offset int9
            mov es:[9*4+2], cs ;更改向量表

          ;显示程序
            mov ax, 0b800h 
            mov es, ax
            mov ah, 'a'
        s:  
            mov  es:[160*12+40*2], ah
            call delay
            inc ah
            cmp ah, 'z'
            jna s

            mov ax, 0
            mov es, ax

          ;向量表归位  
            push ds:[0]
            pop es:[9*4]
            push ds:[2]
            pop es:[9*4+2]

            mov ax, 4c00h
            int 21h

          ;延时程序，根据自己CPU来确定循环次数
     delay: 
            push ax
            push dx
            mov dx, 5h
            mov ax, 0
        s1: 
            sub ax, 1
            sbb dx, 0
            cmp ax, 0
            jne s1
            cmp dx, 0
            jne s1

            pop dx
            pop ax
            ret
          ;更新的9号中断
      int9:
            push ax
            push bx
            push es

            in al, 60h ;读取端口数据

          ;模拟int，因为int9在向量表中变成别的，原来的在ds[2]:ds[0]中
            pushf
            pushf
            pop bx
            and bh, 11111100b
            push bx
            popf
            call dword ptr ds:[0]

          ;是1就改变颜色,不是就跳出
            cmp al, 1
            jne int9ret
            mov ax, 0b800h
            mov es, ax
            inc byte ptr es:[160*12+40*2+1]

    int9ret:
            pop es
            pop bx
            pop ax
            iret
           
code ends
end start
```

## 第15章：外中断

> CPU除了可以执行指令外，还可以对外部设备进行控制，接收输入，进行输出。
>
> 比如， 按下键盘上的一个键，CPU最终要处理这个键，在使用编辑器时，按下键后，对应键上的内容会显示在显示器上。

### 接口芯片和端口

外设的输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中，CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。

端口在CPU传送过程中起到一个桥梁的作用。

### 外中断信息

外设的输入随时都有可能发生，CPU怎么及进知道并作出相应的处理呢？

CPU用中断实现了这种可能，原理上等同于原先的内中断， 但是这个中断信息是由外部产生的。

#### 1. 可屏蔽中断

可屏蔽意味着有两种选择：

* IF = 1，响应中断
* IF = 0,  不响应中断

可屏蔽信息来自于CPU外部，中断类型码通过数据总线送入CPU。

sti，设置IF = 1

cli，设置IF =  0

IF置0的作用不言而喻，在进入中断处理程序后，禁止其他可屏蔽中断。

#### 2. 不可屏蔽中断

是CPU必须响应的中断，CPU执行完当前指令后，立即响应，引发中断过程。

对于8086CPU中断类型码是固定的2，所以中断过程中， 不需要取中断类型码。

> 几乎所有处设引发的中断都是可屏蔽中断。

### PC机键盘的处理过程

#### 1. 键盘输入

键盘上的每一个键都相当于一个开发，键盘中会有一个芯片对键盘上每一个键的开关状态进行扫描。当你按下一个键或松开一个键时都会产生一个扫描码，然后扫描码被送入相关接口芯片的寄存器中，该寄存器的端口地址为60h。

按下一个键产生的扫描码称为**通码**

松开一个键产生的扫描码称为**断码**

> 扫描码的长度为一个字节，通码的第7位为0，断码的第7位为1

所以它们之间相差2^7。也就是80h。

断码 = 通码 + 80h

#### 2. 引发9号中断

#### 3. 执行9号中断例程

BIOS提供了int 9中断例程

![image-20201128093744362](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20201128093744362.png)

#### 编写int 9中断例程

1. 键盘产生扫描码
2. 扫描码送入60上端口
3. 引发9号中断
4. 执行int 9中断例程处理键盘输入

1，2， 3步都是由硬件完成。所以只能改变第4步的中断处理程序。

```
assume cs:code

stack segment
    db 128 dup(0)
stack ends

data segment
    dw 0, 0
data ends

code segment

    start:
            mov ax, stack
            mov ss, ax
            mov sp, 128

            mov ax, data
            mov ds, ax
            
            mov ax, 0
            mov es, ax

            push es:[9*4]
            pop ds:[0]
            push es:[9*4+2]
            pop ds:[2] ;保存9号中断

            cli
            mov word ptr es:[9*4], offset int9
            mov es:[9*4+2], cs ;更改向量表，设置int 9中断例程的段地址和偏移地址
            sti

          ;显示程序
            mov ax, 0b800h 
            mov es, ax
            mov ah, 'a'
        s:  
            mov  es:[160*12+40*2], ah
            call delay
            inc ah
            cmp ah, 'z'
            jna s

            mov ax, 0
            mov es, ax

            cli
          ;向量表归位  
            push ds:[0]
            pop es:[9*4]
            push ds:[2]
            pop es:[9*4+2]
            sti

            mov ax, 4c00h
            int 21h

          ;延时程序，根据自己CPU来确定循环次数
     delay: 
            push ax
            push dx
            mov dx, 5h
            mov ax, 0
            ;循环50000h次
        s1: 
            sub ax, 1
            sbb dx, 0
            cmp ax, 0
            jne s1
            cmp dx, 0
            jne s1

            pop dx
            pop ax
            ret
          ;更新的9号中断
      int9:
            push ax
            push bx
            push es

            in al, 60h ;读取端口数据

            pushf
            call dword ptr ds:[0]

          ;是1就改变颜色,不是就跳出
            cmp al, 1
            jne int9ret
            mov ax, 0b800h
            mov es, ax
            inc byte ptr es:[160*12+40*2+1]

    int9ret:
            pop es
            pop bx
            pop ax
            iret
           
code ends
end start
```

改变中断的我们能做的就只是改变它的向量表。也可以用模拟的手段模拟一个中断。



### 安装新的int9中断例程

执行完后，按esc改变颜色。

```
assume cs:code

stack segment
    db 128 dup(0)
stack ends

code segment

    start:
            mov ax, stack
            mov ss, ax
            mov sp, 128

            push cs
            pop ds

            mov ax, 0
            mov es, ax
            mov di, 204h

            mov si, offset int9
            mov cx, offset int9end - offset int9
            cld 
            rep movsb

            push es:[9*4]
            pop es:[200h]
            push es:[9*4+2]
            pop es:[202h]

            cli
            mov word ptr es:[9*4], 204h
            mov word ptr es:[9*4+2], 0
            sti

            mov ax, 4c00h
            int 21h
     int9:     
            
            in al, 60h
            pushf
            call dword ptr cs:[200h]

            cmp al, 1
            jne int9ret

            mov ax, 0b800h
            mov es, ax
            mov bx, 1
            mov cx, 2000
        s:  
            inc byte ptr es:[bx]
            add bx, 2
            loop s
    int9ret:
            iret

    int9end:
            nop
    

code ends
end start
```

## 第16章：直接定址表

### 描述了单元长度的标号

前面，学了一种标号，可以表示内存单元的地址。现在，在标号后面可以加上长度，不用冒号。表示在此标号处的单元，是一个字节单元，还是字单元，还是双字单元。

#### 检测点

```
assume cs:code

code segment
    a dw 1, 2, 3, 4, 5, 6, 7, 8
    b dd 0 ;从这个地址开始，以后的内存单元都是双字单元

    start:
            mov si, 0
            mov cx, 8

        s:  
            mov ax, a[si]
            add word ptr b[0], ax
            adc word ptr b[2], 0 
            add si, 2 ;每一个单元都是字单元，最小寻址单元是字节，所以用2
            loop s

            mov ax, 4c00h
            int 21h

code ends
end start
```

