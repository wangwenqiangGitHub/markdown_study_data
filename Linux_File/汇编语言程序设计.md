#  第二章：IntelIA-32平台硬件

寄存器核心组

| 寄存器   | 描述                                       |
| -------- | ------------------------------------------ |
| 通用     | 8个32位寄存器，用于存储正在处理的数据      |
| 段       | 6个16位寄存器，用于处理内存访问            |
| 指令指针 | 单一的32位寄存器，指向要执行的下一条指令码 |
| 浮点数据 | 8个80位寄存器，用于浮点数学数据            |
| 控制     | 5个32位寄存器，用于确定处理器的操作模式    |
| 调试     | 8个32位寄存器，用于在调试处理器时包含信息  |

![image-20210427195811117](https://i.loli.net/2021/04/27/jfZMB51aGRoWrcF.png)

![image-20210427195830147](https://i.loli.net/2021/04/27/gVMea8Om3N19o5Y.png)

![image-20210427200719262](https://i.loli.net/2021/04/27/3BPDOynlSpu9at6.png)

![image-20210427200742041](https://i.loli.net/2021/04/27/wEA1cp5gbrzIS2j.png)

![image-20210427200805149](https://i.loli.net/2021/04/27/gX9NWTkSsU6YHaD.png)

![image-20210427200818923](https://i.loli.net/2021/04/27/GmnqlOx6BcH1u75.png)

# 第四章：汇编语言程序范例

## 程序的组成

> 汇编语言由定义好的段构成，每个段都有不同的目的。三个最常用的段是：

* 数据段
* bss段
* 文本段(不可少)：放指令码的地方

## 定义段

> .section .data
>
> .section .text
>
> .section .bss

## 定义起始点

> GNU汇编器声明一个默认标签，用作应用程序入口点：_start标签

```assembly
.section .data

.section .bss

.section .text
.globl _start
_start:

```

**.globl命令声明外部程序可以访问的程序标签。**

## 简单程序

```assembly
.section .data #数据段
output: #output标签指示内存地址
    .ascii "The processor Vendor ID is 'xxxxxxxxxxxx'\n"
           #01234567890123456789012345678

.section .text #文本段，不可少
.global _start#.global声明外部程序可以访问的标签，起始标签_start

_start:
#找到CPU信息
    movl $0, %eax #将eax置0(操作数与结果数的累加器)，eax寄存器中的数字决定CPUID指令生成什么信息
    cpuid #运行CPUID指令

#操作output地址
    movl $output, %edi #edi用于字符串操作的目标的数据指针，output标签的内存位置被加载到EDI寄存器中

#写入地址
    movl %ebx, 28(%edi) #将ebx中的字符替代edi＋28开始的地址上的值
    movl %edx, 32(%edi)
    movl %ecx, 36(%edi)

#显示
    movl $1, %ebx #ebx包含要写入的文件描述符，1(文件描述符)表示STDOUT(标准输出) 
    movl $4, %eax #eax包含系统调用值
    movl $output, %ecx #ecx包含字符串的开头
    movl $42, %edx #edx包含字符串的长度
    int $0x80 #Linux内核函数访问，必须使用int指令码

    movl $0, %ebx
    movl $1, %eax
    int $0x80
```

Makefile文件

```makefile
target:= cpuid
objs:= $(patsubst %.s, %.o, $(wildcard *.s))
    
$(target): $(objs)
    ld $^ -o $@
$(objs): %.o: %.s 
    as -gstabs $< -o $@ #生成有调试信息的目标文件

.PHONY: clean

clean:
    -rm $(target) $(objs)

```

## GDB调试

### 打断点

```assembly
break * label+offset #标签加相对行数
```

> 断点与标签有关，指令码段中就一个_start标签。

### 单步

```assembly
step/s
next/n
```

### 查看数据

查看所有寄存器的值：

```assembly
info registers
```

根据修饰符确定打印输出格式：

```assembly
print/d #显示十进制的值
print/t #显示二进制的值
print/x #显示十六进制的值
print/x $rcx
```

![image-20210426093347778](https://i.loli.net/2021/04/26/FwqTP3AnbW8VcYK.png)

x用于显示特定内存位置的值。

```assembly
x/nyz + 内存位置
```

* n是要显示的字段数
* y是输出格式
  * c字符
  * d十进制数
  * x十六进制数
* z是要显示的字段长度
  * b用于字节
  * h用于16位字（半字）
  * w用于32位字

![image-20210426093718317](https://i.loli.net/2021/04/26/8UnAcCK1xTO9Gi5.png)

## 使用C函数

```assembly
.section .data #数据段
output: #output标签指示内存地址
    .asciz "The processor Vendor ID is '%s'\n" #.asciz会在结尾添加空字符
           #01234567890123456789012345678
.section .bss
    .lcomm buffer, 12 #.lcomm命令声明12个字节缓冲区

.section .text#文本段，不可少
.globl _start#声明外部程序可以访问的标签，起始标签_start

_start:
#找到CPU信息
    movl $0, %eax #将eax置0(操作数与结果数的累加器)，eax寄存器中的数字决定CPUID指令生成什么信息
    cpuid #运行CPUID指令

#操作output地址
    movl $buffer, %edi

#写入地址
    movl %ebx, (%edi) #将ebx中的字符替代edi＋28开始的地址上的值
    movl %edx, 4(%edi)
    movl %ecx, 8(%edi)

#显示
    pushl $buffer #先入栈，后获取
    pushl $output
    call printf
    addl $8, %esp #清空堆栈参数

    pushl $0 #把0值放入堆栈中供C函数exit使用
    call exit

```

```makefile
target:= cpuid
objs:= $(patsubst %.s, %.o, $(wildcard *.s))

$(target): $(objs)
    ld -m elf_i386 -dynamic-linker /lib/ld-linux.so.2 $^ -o $@ -lc #链接32位库,指定在运行时加载动态库的程序。
$(objs): %.o: %.s 
    as -gstabs --32 $< -o $@ #生成32位目标文件

.PHONY: clean

clean:
    -rm $(target) $(objs)

```

[32位汇编在64位Ubuntu上运行]([X86_64平台下32位汇编语言调用C库函数程序的汇编与链接 - 飛竹的个人空间 - OSCHINA - 中文开源技术交流社区](https://my.oschina.net/u/1167407/blog/484426))

`sudo apt-get install libc6-dev-i386`

# 第五章：传送数据

## 5.1 定义数据元素

### 5.1.1 数据段

```
声明：.data 在这个段中声明的任何数据元素都保留在内存中并且可以被汇编语言程序中的指令读取和写入
```

```
声明：.rodata 只读
```

```assembly
.section 声明
	标签：
	命令
```

标签对处理器是没有意义的，它只是汇编器试图访问内存位置时用作引用指针的一个位置。

命令：定义数据元素保留多少个字节。

.ascii自带'\n'

![image-20210426192850642](https://i.loli.net/2021/04/26/MheJa7BPgt6dr1j.png)

```assembly
.section data
	output:
	.ascii "Hello World!\n"
```

数据在内存中存放时，最低的内存位置存放第一个出现的元素，然后按命令中列出的顺序向高地址存放。

```cassandra
.section .data
height:
	.int 54
length:
	.int 62, 35, 47
```

![image-20210503211111914](https://i.loli.net/2021/05/03/KLUrN5JGClxdgWD.png)

#### 5.1.2静态符号

数据段中可以定义静态符号，不能在程序中改动。可以出现在数据段中的任何位置。

```assembly
.equ factor, 3
```

引用时必须在前面加上$。

```assembly
movl $facor, %eax
```

### 5.1.3 bss段

![image-20210426193345655](https://i.loli.net/2021/04/26/shX9xGBp6wlzk84.png)

本地通用内存区域是为(不会从本地汇编代码之外进行访问的数据)内部汇编保留的。

```assembly
.comm symbol, length #symbol是赋给内存区域的标签，length是内存区域中包含的字节数量
```

```assembly
.section bss
.lcomm buffer, 10000
```

把10000字节的内存区域赋值给buffer标签，在声明本地通用内存区域的程序之外的函数(.globl命令中)是不能访问它们的

bss的好处是不包含在可执行程序中，数据段会被包含在可执行程序中，因为它必须初始化。不用初始化，所以内存区域被保留在运行时使用，不包含在最终程序中。

![image-20210427202141055](https://i.loli.net/2021/04/27/HU2Witvl4IqCmoh.png)

生成可执行文件大小如下：

![image-20210427202255025](https://i.loli.net/2021/04/27/rbJDxLhXOTym4ap.png)

.fill命令使汇编器自动地创建了10000个数据元素。默认为每个字段创建一个字节，并且使用零填充它。

## 5.2 传送数据元素

数据元素位于内存中，CPU很多指令要用到寄存器，处理数据的第一个步骤就是在**内存与寄存器之间的数据传送它们。**

### 5.2.1 MOV指令格式

```assembly
movx source, destination
```

source与destination的值可以是内存地址、存储在内存中的数据值、指令语句中定义的数据值或者是寄存器

> 与Intel不同的是，源地址与目的地址编写顺序相反

x可以是以下值：

* l用于32位长字值

  ```assembly
  movl %eax, %ebx
  ```

* w用于16位字值

  ```assembly
  movw %ax, %bx
  ```

* b用于8位字节值

  ```assembly
  movb %al, %bl
  ```

### 5.2.2 把立即数送到寄存器和内存

```assembly
movl $0, %eax
movl $0x80, %ebx
movl $100, height
```

==每个值前面加上$符号表示它是立即值。==程序被汇编和连接为可执行程序文件后，这些值就不可以改变了。

### 5.2.3 在寄存器之间传送数据

```assembly
movl %eax, %ecx
movw %ax, %cx
```

不要在长度不同的寄存器之间传送数据。

```assembly
movb %al, %bx
```

8个通用寄存器的内容可以传送给可用的任何其它类型的寄存器，而专用寄存器（控制、调试、段寄存器）的内容只能传送给通用寄存器。

### 5.2.4 在内存和寄存器之间传送数据

1. 把数据值从内存传送到寄存器

   如果在指令中表示内存地址？使用标签：

   ```assembly
   movl value, %eax
   ```

   把位于value标签指定的内存位置的数据值传送给EAX寄存器。movl传送32位信息，它传送从value标签引用的内存位置开始的4字节数据。如果数据长度小于4节节就要用movb和movw。

   ```assembly
   .section .data
       value:
           .int 1
   .section .text
   
   .globl _start
   _start:
       nop 
       movl value, %ecx
   
       movl $1, %eax
       movl $0, %ebx
       int $0x80
   ```

2. 把数据值从寄存器传送给内存

   ```assembly
   movl %ecx, value
   ```

   将ecx寄存器中的4个字节数据传送给value标签指定的内存位置。

   ```assembly
   .section .data
       value:
           .int 1
   
   .section .text
   .globl _start
   _start:
       movl $100, %eax
       movl %eax, value
   
       movl $1, %eax
       movl $0, %ebx
       int $0x80
   ```

   通过标签引用单一数据元素时这样做还不错。

3. 使用变址的内存位置

   ```assembly
   .section .data
   output:
       .ascii "The value is %d"
   #可以在命令中指定把多个值存放到内存中
   values:
       .int 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60
   
   .section .text
   .globl _start
   _start:
       nop 
       movl $0, %edi
   
   loop:
       movl values(, %edi, 4), %eax
       pushl %eax
       pushl $output
       call printf
       addl $8, %esp
       inc %edi
       cmpl $11, %edi #判断，此处使用了硬编码的值，在实际中，会希望动态定数组的项目数。
       jne loop #跳转
       
       movl $1, %eax
       movl $0, %ebx
       int $0x80
   
   ```

   根据变址系统确定要访问的值是哪个。此操作方式称为变址内存模式(indexed memory mode)。内存位置由以下四个因素确定：

   * 基址
   * 添加到基址上的偏移地址
   * 数据元素的长度
   * 确定选择哪个数据元素的变址(从0开始，第几个元素)

   ```assembly
   base_address(offset_address, index, size)
   ```

   获取的数据位置位于： 

   base_address + offset_address + index * size

   其中有值为0时，可以不写，但位置要保留，与for循环一样。`offset_address`与`index`的值必须是寄存器。`size`可以是数据值。

4. 使用寄存器间接寻址

> 寄存器还可以保存内存地址！这时，它叫指针(pointer)。
>
> 使用指针访问存储在内存位置中的数据称为间接寻址(indirect addressing)。

标签引用内存位置中包含的数据值时，可以在前面加上$获得内存位置的地址。

```assembly
movl $values, %edi
```

把values标签引用的内存地址传送给EDI寄存器。

*在平坦内存模型中，所有内存地址都是使用32位数字表示的*

```assembly
movl %ebx, %edi #将EBX寄存器中的值加载到EDI寄存中
movl %ebx, (%edi) #将EBX寄存器中的值传送给EDI寄存器中包含的内存位置
movl %ebx, 4(%edi) #将EBX寄存器中的值存入在EDI寄存器指向的位置之后的4个字节的内存位置中
movl 4(%edi), %ebx #将4字节的内存位置存入EBX寄存器中
```

当寄存器外加括号时，就等同于C语言中\*p作为左值，改变内存地址。

 ## 5.3 条件传送指令

> 在特定的条件下mov

### 5.3.1 CMOV指令

```assembly
comvx source, destination
```

x是一个或两个字母的代码，表示触发mov的条件，取决于EFLAGS寄存器的当前值。

![20190126013422181](https://i.loli.net/2021/05/09/7xzvDWyUupAb5hH.png)

条件传送指令使用的特定位如下表：

![image-20210430095912651](https://i.loli.net/2021/04/30/Wfhb3ncDwzGElvP.png)

条件传送指令分组在一起，两个指令具有相同的含义。不大于等价于小于等于，其却具有各自的传送指令。

无符号传送指令：

![image-20210430100204754](https://i.loli.net/2021/04/30/m4qionByXUHhfEt.png)

大于(above)，等于(equals)，小于(below)，零(zero)

有符号传送指令：

![image-20210430100408989](https://i.loli.net/2021/04/30/jeI8M5HVtPpCrRb.png)

大于(greater)，小于(less)

### 5.3.2 使用

下面的代码找到整数数组中最大的那一个：

```assembly
.section .data
output:
    .asciz "The largest value is %d\n"
values:
    .int 105, 235, 61, 315, 134, 221, 53, 145, 117, 5
.section .text
.globl _start
_start:
    movl values, %ebx #ebx存一住第一个值
    movl $1, %edi #edi为1

loop:
    movl values(, %edi, 4), %eax #数组第一位的值给eax 
    cmp %ebx, %eax #eax - ebx 
    cmova %eax, %ebx #ebx存大的

    inc %edi #指针加1 
    cmp $10, %edi #edi-10
    jne loop

    #输出
    pushl %ebx
    pushl $output
    call printf
    addl $8, %esp
    pushl $0
    call exit
```

```assembly
cmp %ebx, %eax #用第二个操作数减去第一个操作数设置EFLAGS的值
cmova %ecx, %ebx #如果结果是大于0，就把ecx的值装入ebx中
```

## 5.4 交换数据

### 5.4.1 数据交换指令

![image-20210430102256514](https://i.loli.net/2021/04/30/id6fHrBuSyGRjcg.png)

1. xchg

   ```assembly
   xchg operand1, operand2
   ```

   操作数可以是通用寄存器，也可是内存位置，但是不能同时是内存位置，长度必须相同。当一个操作是内存位置时，处理器的LOCK信号被自动标明，防止其它处理器访问这个位置，这是非常耗时的。

2. bswap

   ```assembly
   bswap %eax
   ```

   反转寄存器的字节，比如32位（4字节）寄存器，第1，4字节交换，第2，3字节交换

   ```assembly
   .section .data
   output:
       .asciz "ebx is %x\n"
   
   .section .text
   .globl _start
   _start:
   
       movl $0x12345678, %ebx
       pushl %ebx
       pushl $output
       call printf
       addl $8, %esp
   
       bswap %ebx
   
       pushl %ebx
       pushl $output
       call printf
       addl $8, %esp
   
       movl $1, %eax
       movl $0, %ebx
       int $0x80
       
   #ebx is 12345678
   #ebx is 78563412
   ```

3. xadd

   ```assembly
   xadd source, destination
   ```

   soure必需是寄存器，destination可以是寄存器，也可以是内存位置。destination包含相加的结果。

4. cmpxchg

   ```assembly
   cmpxchg source, destination
   ```

   比较目标操作数和EAX、AX或者AL寄存器的值。相等就把源操作数(source)放入目标操作数(destination)中，不等就把目标操作数加载到EAX、AX或者AL寄存器中。

5. cmpxchg8b

   ```assembly
   cmpxchg8b destination
   ```

   destination引用一个内存位置，其中8字存的值会与EDX和EAX寄存器中包含的值进行比较(EDX高位，EAX低位)，如果相等，就把ECX:EBX中的值送入destination，不相等就把destination送入EDX:EAX中。

   ```assembly
   .section .data
   output:
       .asciz "This is %x \n"
   data:
       .byte 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88
   
   .section .text
   .globl _start
   
   _start:
       movl $0x44332211, %eax
       movl $0x13242424, %ebx
       movl $0x22348223, %ecx
       movl $0x88776655, %edx
   
       cmpxchg8b data #EDX:EAX = data ECX:EBX送入data
   
       pushl data
       pushl $output
       call printf
       addl $8, %esp
   
       cmpxchg8b data	#EDX:EAX != data EDX:EAX送入data
       
       pushl %eax
       pushl $output
       call printf
       addl $8, %esp
   
       movl $1, %eax
       movl $0, %ebx
       int $0x80
   
   ```

### 5.4.2 使用

冒泡排序

```assembly
.section .data
output:
    .asciz "is %d\n"
values:
    .int 105, 235, 61, 315, 134, 221, 53, 145, 117, 5

.section .text
.globl _start
_start:
    movl $values, %esi #esi指向values地址
    movl $9, %ecx #外层循环计数
    movl $9, %ebx #内层循环计数
loop:
    movl (%esi), %eax 
    cmp %eax, 4(%esi) #比较，后者-前者
    jg skip #如果大于就跳到skip
    xchg %eax, 4(%esi) #如果小于就交换
    movl %eax, (%esi)
skip:
    add $4, %esi 
    dec %ebx #计数减一
    jnz loop #内层循环
    dec %ecx
    jz end
    movl $values, %esi
    movl %ecx, %ebx #有ecx个最小的已经挑选出来了
    jmp loop
end:
    movl $0, %edi
loop2:
    movl values(, %edi, 4), %eax
    pushl %eax
    pushl $output
    call printf
    addl $8, %esp
    inc %edi
    movl $9, %ebx
    cmp %edi, %ebx
    jnz loop2

    movl $1, %eax
    movl $0, %ebx
    int $0x80

```

```
is 5
is 53
is 61
is 105
is 117
is 134
is 145
is 221
is 235
```

## 5.5 堆栈

与数据段数据从低地址向高地址放入内存位置不同，堆栈是从高地址向低地址放入。为什么会出现这种情况，可能因为堆栈的大小是人为确定的，取数据时常从低地址开始取，保证先入后出，所以从高地址先放。

![image-20210503212613417](https://i.loli.net/2021/05/03/LnAx61wHNX5aj8c.png)

### 5.5.2 压入和弹出堆栈数据

```assembly
pushx source
```

```assembly
pushl %ecx
pushw %cx
pushl $100
pushl data #值放入堆栈中
pushl $data #data标签引用的地址放入堆栈中
```

```assembly
popx destination
```

### 5.5.3 压入和弹出所有寄存器

![image-20210430191805610](https://i.loli.net/2021/04/30/CzOUbYdHIyJtcnr.png)

### 5.5.4 手动使用ESP和EBP寄存器

可以通过使用ESP寄存器作为内存指针，手工把数据放入堆栈中。会看到很多程序把ESP寄存器的值复制到EBP寄存器，而不是使用ESP寄存器本身。

```assembly
pushl %ebx
pushl %ecx

movl %ebx, 4(%esp)
movl %ecx, (%esp)
```

# 第六章：控制执行流程

## 6.1 指令指针

* 分支 ：改动指令指针的指令
  * 条件分支
  * 无条件分支

## 6.2 无条件分支

* 跳转
* 调用
* 中断

### 6.2.1 跳转

```assembly
jmp location
```

在幕后，此单一的汇编指令被汇编为跳转操作码的3种不同类型之一。

* 短跳转
* 近跳转
* 远跳转

类型是由当前指令的内存位置和跳转到的内存位置之间的距离决定的。

```assembly
.section .text
.globl _start
_start:
    movl $1, %eax
    jmp overhere
    movl $10, %ebx
    int $0x80
overhere:
    movl $20, %ebx
    int $0x80
```

```
objdump -D test #反汇编经过汇编的代码
```

```assembly
test：     文件格式 elf32-i386

Disassembly of section .interp:

Disassembly of section .text:

0804814b <_start>:
 804814b:   b8 01 00 00 00          mov    $0x1,%eax
 8048150:   eb 07                   jmp    8048159 <overhere>
 8048152:   bb 0a 00 00 00          mov    $0xa,%ebx
 8048157:   cd 80                   int    $0x80

08048159 <overhere>:
 8048159:   bb 14 00 00 00          mov    $0x14,%ebx
 804815e:   cd 80                   int    $0x80

```

```c
Reading symbols from ./test...done.
(gdb) b *_start
Breakpoint 1 at 0x804814b: file main.s, line 4.
(gdb) r
Starting program: /home/zs/Assembly/6/2/1/test 

Breakpoint 1, _start () at main.s:4
4	    movl $1, %eax
(gdb) n
5	    jmp overhere
(gdb) p/x $eip
$1 = 0x8048150
(gdb) n
9	    movl $20, %ebx
(gdb) p/x $eip
$2 = 0x8048159
(gdb) 
```

### 6.2.2 调用

```assembly
call address #把EIP保存到ESP中，修改EIP为address
ret #把ESP弹出到EIP
```

```assembly
.section .data
output:
    .asciz "This is section %d\n"
.section .text
.globl _start
_start:
    pushl $1
    pushl $output
    call printf
    add $8, %esp
    call overhere
    pushl $3
    pushl $output
    call printf
    add $8, %esp
    pushl $0
    call exit

overhere:
    pushl $2
    pushl $output
    call printf
    add $8, %esp
    ret 
```

```assembly
test：     文件格式 elf32-i386


Disassembly of section .plt:

080481c0 <.plt>:
 80481c0:	ff 35 04 a0 04 08    	pushl  0x804a004
 80481c6:	ff 25 08 a0 04 08    	jmp    *0x804a008
 80481cc:	00 00                	add    %al,(%eax)
	...

080481d0 <printf@plt>:
 80481d0:	ff 25 0c a0 04 08    	jmp    *0x804a00c
 80481d6:	68 00 00 00 00       	push   $0x0
 80481db:	e9 e0 ff ff ff       	jmp    80481c0 <.plt>

080481e0 <exit@plt>:
 80481e0:	ff 25 10 a0 04 08    	jmp    *0x804a010
 80481e6:	68 08 00 00 00       	push   $0x8
 80481eb:	e9 d0 ff ff ff       	jmp    80481c0 <.plt>

Disassembly of section .text:

080481f0 <_start>:
 80481f0:	6a 01                	push   $0x1
 80481f2:	68 14 a0 04 08       	push   $0x804a014
 80481f7:	e8 d4 ff ff ff       	call   80481d0 <printf@plt>
 80481fc:	83 c4 08             	add    $0x8,%esp
 80481ff:	e8 16 00 00 00       	call   804821a <overhere>
 8048204:	6a 03                	push   $0x3
 8048206:	68 14 a0 04 08       	push   $0x804a014
 804820b:	e8 c0 ff ff ff       	call   80481d0 <printf@plt>
 8048210:	83 c4 08             	add    $0x8,%esp
 8048213:	6a 00                	push   $0x0
 8048215:	e8 c6 ff ff ff       	call   80481e0 <exit@plt>

0804821a <overhere>:
 804821a:	6a 02                	push   $0x2
 804821c:	68 14 a0 04 08       	push   $0x804a014
 8048221:	e8 aa ff ff ff       	call   80481d0 <printf@plt>
 8048226:	83 c4 08             	add    $0x8,%esp
 8048229:	c3                   	ret    
```

### 6.2.3 中断

处理器“中断”当前路径并且切换到不同路径的方式。

* 软件中断
* 硬件中断

## 6.3 条件分支

### 6.3.1 条件跳转指令

```assembly
jxx address
```

![image-20210430202433594](https://i.loli.net/2021/04/30/DzVKTYOReFva6oq.png)

无符号值用JA(Above)，有符号用JG(greater)。

> 在指令码中，条件跳转指令使用单一操作数——要跳转到的地址。这个操作数常常是汇编程序中的一个标签，在指令码中被转换为偏移地址。

条件跳转允许：

* 短跳转：8位带符号地址偏移量
* 近跳转：16位或32位带符号地址偏移量

**条件跳转指令不支持分段内存模式下的远跳转，此时要使用无条件跳转（保证条件存在）。**

### 6.3.2 比较指令

```assembly
cmp operandl, operand2
```

在幕后，它对两个操作数执行减法操作(operand2 - operand1)，这样会设置EFLAGS寄存器。

 ```assembly
.section .data

.section .text
.globl _start
_start: 
    movl $15, %eax
    movl $10, %ebx
    cmp %eax, %ebx
    jge greater
    movl $1, %eax
    int $0x80
greater:
    movl $20, %ebx
    movl $1, %eax
    int $0x80
 ```

```
echo $?
10
```

```assembly
cmp $20, %ebx
cmp data, %ebx
cmp (%edi), %ebx compare EBX with the value referenced by the EDI pointer 比较EBX与指针指向内存地址的数值
cmp 4(%edi), %ebx
```

### 6.3.3 使用标志位

1. 使用零标（Zero Flag）志

   零标志可以由CMP指令设置， 也可以由计算结果为零的数学指令设置。

   ```assembly
   movl $30, %eax
   subl $30, %eax
   jz overthere
   ```

   ```assembly
   movl $10, %edi
   loop:
   	<other code instructions>
   	dec %edi
   	jz out
   	jmp loop
   out:
   ```

2. 使用溢出（Overflow Flag）标志

   溢出专门用在处理有符号数字时，超过了表示范围就是溢出。

   ```assembly
   movl $1, %eax
   movb $0x7f, %bl #有符号数127
   addb $10, %bl #127+10 = 137超过8位有符号数的表示范围，产生溢出
   jo overhere
   	int $0x80
   overhere:
   	mov $0, %ebx
   	int $0x80
   ```

3. 使用奇偶（Parity Flag）校验标志

   采用二进制结果中1的个数是奇数时来进行奇偶校验。==准确来说，其叫做奇校验。==1的个数为奇数，PF=0，1的个数为偶数，PF=1。

   ```assembly
   .section .text
   .globl _start
   _start:
   	movl $1, %eax
   	movl $4, %ebx
   	subl $3, %ebx #结果为1，二进制中只有一个1，PF=0，不跳转
   	jp overhere
   	int $0x80
   overhere:
   	movl $100, %ebx
   	int $0x80
   ```

4. 使用符号（signtest.s）标志

   表示寄存器中包含的值的符号改变。带符叼数中，最高位被用作符号位。正值为0，负值为1。

   ```assembly
   .section .data
   output:
       .asciz "The value is: %d\n"
   value:
       .int 23, 32, 23, 32, 32, 23, 32, 2, 324, 33
   .section .text
   .globl _start
   _start:
       movl $9, %edi
   loop:
       pushl value(, %edi, 4)
       pushl $output
       call printf
       addl $8, %esp
       dec %edi
       jns loop #没有符号（没到-1）就跳转
       movl $1, %eax
       movl $0, %ebx
       int $0x80
   ```

5. 使用进位（Carry Flag）标志

   表示无符号数何时溢出（即要表示的数超过寄存器限制的长度）。<font color = red>与溢出标志不同，DEC和INC指令不影响进位标志。</font>

   ```assembly
   movl $0xffffffff, %ebx
   inc %ebx #无进位
   jc overflow
   
   movl $0xffffffff, %ebx
   addl $1, %ebx #有进位
   jc overflow
   
   movl $2, %eax
   subl $4, %eax #有进位
   jc overflow
   ```

   ![image-20210502215502611](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20210502215502611.png)

## 6.4 循环

![image-20210503214636496](https://i.loli.net/2021/05/03/szkgP2x7SGfRKLe.png)

 ### 6.4.2 范例

```assembly
.section .data
output:
    .asciz "The value is: %d\n"
.section .text
.globl _start
_start:
    movl $100, %ecx
    movl $0, %eax

loop1:
    addl %ecx, %eax
    loop loop1
    pushl %eax
    pushl $output
    call printf
    addl $8, %esp
    movl $1, %eax
    movl $0, %ebx
    int $0x80
```

### 6.4.3 防止LOOP灾难

当执行LOOP指令时，首先将ECX中的值减1，再检查ECX值是否为0。显然，若ECX中初始值为0，就会带来灾难。可以使用jecx来避免。

```assembly
.section .data
output:
    .asciz "The value is: %d\n"
.section .text
.globl _start
_start:
    movl $0, %ecx
    movl $0, %eax
    jcxz done #jecxz done发现cx/ecx寄存器中的值为0

loop1:
    addl %ecx, %eax
    loop loop1
    
done:
    pushl %eax
    pushl $output
    call printf
    addl $8, %esp
    movl $1, %eax
    movl $0, %ebx
    int $0x80
```

## 6.5 模仿高级条件分支

### 6.5.1 if语句

```c
#include <stdio.h>

int main(void)
{
    int a = 100;
    int b = 25; 
    if (a > b)
    {   
        printf("The higher value is %d\n", a); 
    }   
    else
    {   
        printf("The higher value is %d\n", b); 
    }   
    return 0;
}
```

```assembly
    .file   "main.c"
    .text
    .section    .rodata
.LC0:
    .string "The higher value is %d\n"
    .text
    .globl  main
    .type   main, @function
main:
.LFB0:
    .cfi_startproc
    ####################固定语法#######################
    pushq   %rbp
    .cfi_def_cfa_offset 16
    .cfi_offset 6, -16
    movq    %rsp, %rbp
    .cfi_def_cfa_register 6
    subq    $16, %rsp
    ####################固定语法######################
    movl    $100, -8(%rbp)
    movl    $25, -4(%rbp)
    movl    -8(%rbp), %eax
    cmpl    -4(%rbp), %eax
    jle .L2 #小于或等于
    movl    -8(%rbp), %eax #100
    movl    %eax, %esi
    leaq    .LC0(%rip), %rdi
    movl    $0, %eax
    call    printf@PLT
    jmp .L3
.L2:
    movl    -4(%rbp), %eax #25
    movl    %eax, %esi
    leaq    .LC0(%rip), %rdi
    movl    $0, %eax
    call    printf@PLT
.L3:
    movl    $0, %eax
    leave
    .cfi_def_cfa 7, 8
    ret
    .cfi_endproc
.LFE0:
    .size   main, .-main
    .ident  "GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0"
    .section    .note.GNU-stack,"",@progbits

```

### 6.5.2 for语句

```c
#include <stdio.h>

int main(void)
{
    int i = 0;
    int j;
    for (i = 0; i < 1000; i++)
    {   
        j = i * 5;
        printf("The answer is %d\n", j); 
    }   
    return 0;
}
```



```assembly
.file   "main.c"
    .text
    .section    .rodata
.LC0:
    .string "The answer is %d\n"
    .text
    .globl  main
    .type   main, @function
main:
.LFB0:
    .cfi_startproc
    pushq   %rbp
    .cfi_def_cfa_offset 16
    .cfi_offset 6, -16 
    movq    %rsp, %rbp
    .cfi_def_cfa_register 6
    subq    $16, %rsp
    movl    $0, -8(%rbp)
    movl    $0, -8(%rbp)
    jmp .L2 
.L3:
    movl    -8(%rbp), %edx
    movl    %edx, %eax
    sall    $2, %eax
    addl    %edx, %eax
    movl    %eax, -4(%rbp)
    movl    -4(%rbp), %eax
    movl    %eax, %esi
    leaq    .LC0(%rip), %rdi
    movl    $0, %eax
    call    printf@PLT
    addl    $1, -8(%rbp)
.L2:
    cmpl    $999, -8(%rbp)
    jle .L3 #小于或等于就跳转到.L3
    movl    $0, %eax
    leave
    .cfi_def_cfa 7, 8
    ret 
    .cfi_endproc
.LFE0:
    .size   main, .-main
    .ident  "GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0"
    .section    .note.GNU-stack,"",@progbits                              
```

## 6.6 优化分支指令

> 现代处理器使用指令预取缓存提高性能，乱序引擎试图尽可能快地执行指令，这样，分支严重影响应用程序的性能。

### 6.6.1 分支预测

1. 无条件分支

   可以确定下一条指令，但跳转距离是个问题。如果太远缓存中没有，就要清空缓存找后面的。

2. 条件分支

   分支预测算法猜测特定的条件分支将采用哪条路径，主要规则是：

   * 假设会采用向后分支
   * 假设不会采用向前分支
   * 以前曾采用过的分支会再次采用

   如果按照这些规则来做，你的代码会更快。

#### 假设会采用向后分支

> 最常见的向后分支是循环中遇到的，即跳转到前面的代码去执行。

```assembly
	movl $100, $ecx
loop1:
	addl %cx, %eax
	decl %ecx
	jns loop1
```

这条分支会向后执行100次，预测101次只会有一次是错误的。

#### 假设不会采用向前分支

> 分支预测算法假设大多数情况下条件分支不会采用向前的方向，也就是说：紧跟在条件跳转指令之后的代码最先执行。

```assembly
main:
.LFB0:
    .cfi_startproc
    ####################固定语法#######################
    pushq   %rbp
    .cfi_def_cfa_offset 16
    .cfi_offset 6, -16
    movq    %rsp, %rbp
    .cfi_def_cfa_register 6
    subq    $16, %rsp
    ####################固定语法######################
    movl    $100, -8(%rbp)
    movl    $25, -4(%rbp)
    movl    -8(%rbp), %eax
    cmpl    -4(%rbp), %eax
    jle .L2 #小于或等于
    movl    -8(%rbp), %eax #100
    movl    %eax, %esi
    leaq    .LC0(%rip), %rdi
    movl    $0, %eax
    call    printf@PLT
    jmp .L3
.L2:
    movl    -4(%rbp), %eax #25
    movl    %eax, %esi
    leaq    .LC0(%rip), %rdi
    movl    $0, %eax
    call    printf@PLT
```

这里用

```assembly
jle .L2
```

表明编译器猜测大于的可能性更大，而放在跳转语句之后。小于等于则放在向前分支中。

### 6.6.2 优化技巧

人们可以在写汇编时帮助处理器减少麻烦。

1. 消除分支

   Intel提供一些专门的指令来帮助达到这个目的。

   ```assembly
   movl value, %ecx
   cmpl %ebx, %ecx
   cmova %ecx, %ebx #ecx大于ebx就ecx中的值送入到ebx中
   ```

   这样我们写找最大值程序就不用那么多的跳转指令了。

   循环中的分支的错误写法会导致性能降低：

   ```assembly
   loop:
   	cmp data(, %edi, 4), %eax
   	je part2
   	call functionl
   	jmp looptest
   part2:
   	call function2
   looptest:
   	inc %edi
   	cmpl $10, %edi
   	jnz loop
   ```

   调用第一个函数时，就要对jmp进行提前判断去哪里，预测算法不会预测它向前跳转，而jmp是一个向前跳转的指令，会导致性能损失。

   改成下面的：

   ```assembly
   loop:
   	cmp data(, %edi, 4), %eax
   	je part2
   	call functionl
   	inc %edi
   	cmpl $10, %edi
   	jnz loop
   	jmp end
   part2:
   	call function2
   	#############重复语句###################
   	inc %edi
   	cmpl $10, %edi
   	jnz loop
   	#############重复语句###################
   end:
   ```

   尽管写了几条重复语句，但消除了向前跳转带来的性能损失。

2. 首先编写可预测的代码

   把最可能采用的代码安排在向前跳转语句后。

   ![image-20210505141805952](https://i.loli.net/2021/05/07/O5XmrYfju4x3QLT.png)

3. 展开循环

   ```assembly
       movl values, %ebx #ebx存一住第一个值
       movl $1, %edi #edi为1
   
   loop:
       movl values(, %edi, 4), %eax #数组第一位的值给eax 
       cmp %ebx, %eax #eax - ebx 
       cmova %eax, %ebx #ebx存大的
   
       inc %edi #指针加1 
       cmp $4, %edi #edi-4
       jne loop
   ```

   4次循环体全部展开写一遍，会使指令数量增加。对于不长的循环可以这样做，太长的循环这么写会导致过度填充缓存。会使处理器不断的填充和清空预取的缓存。

# 第七章：使用数字

## 7.1 数字数据类型

![image-20210506213754980](https://i.loli.net/2021/05/07/X5duEJIPsDt891G.png)

## 7.2 整数

### 7.2.1 标准整数长度

IA-32平台支持4种不同的整数长度：

* 字节(Byte)：8位
* 字(Word)：16位
* 双字(Doubleword)：32位
* 四字(Quadword)：64位

> 存储在内存中的超过一个字节的整数被存储为小尾数(little-endian)格式，低位在低内存位置。内存真实就是这么存的，Debug时print结果与人类写法相反。比如十进制数549，0x00000225

内存中是这样存的：25 02 00 00(左边是内存最低位)

> 在寄存器中，值按照大尾数(big-endian)格式存储在寄存器中，给人看的那种。书中并没有明确说寄存器中的内存是什么样的，可以理解为寄存器Debug时print的结果就是给人看的，与人类写法一致。若从左为内存最低位置，那就满足大尾数的条件。

寄存器中十进制549就是：0x00000225

### 7.2.2 无符号整数

上节说道，整数在寄存器中存法与人类写法一致。

![image-20210506215034205](https://i.loli.net/2021/05/07/HLEeX2cwbkt7Myg.png)

### 7.2.3 带符号整数

3种方法用于在计算机中描述负数：

* 带符号数值
* 反码(One's complement)
* 补码(Two's complement)

IA-32用补码来表示带符号整数。

### 7.2.4 使用带符号整数

```assembly
.section .data
data:
    .int -45 
.section .text
.globl _start
_start:
    movl $-345, %ecx
    movl $0, %edx
    movw $0xffb1, %dx 
    movl data, %ebx
    movl $1, %eax
    int $0x80
```

```assembly
(gdb) info reg
eax            0xf7ffd940	-134227648
ecx            0xfffffea7	-345
edx            0xffb1	65457
ebx            0xffffffd3	-45
```

0xffb1对于单字整数来说是有符号的值-79，但是调试器把EDX当成一个整体没有把符号保存过去，变成了0x0000ffb1 = 65457了。

### 7.2.5 扩展整数

1. `movzx source, destination`

   长度小的无符号整数值扩展为长度大的无符号整数值。

2. `movsx source, destination`

   长度小的有符号整数值扩展为长度大的有符号整数值。可以保留符号。

   ```assembly
   .section .text
   .globl _start
   _start:
       movw $-79, %cx 
       movl $0, %ebx
       movw %cx, %bx 
       movsx %cx, %eax
       movl $1, %eax
       movl $0, %ebx
       int $0x80
   
   ```

   ```assembly
   (gdb) info reg
   eax            0xffffffb1	-79
   ecx            0xffb1	65457
   edx            0xf7fe5970	-134325904
   ebx            0xffb1	65457
   ```

   显然eax用了指令是负值，ecx，ebx没用指令还是正的。

   ```assembly
   .section .text
   .globl _start
   _start:
       movw $79, %cx 
       movl $0, %ebx 
       movw %cx, %bx 
       movsx %cx, %eax
       movl $1, %eax
       movl $0, %ebx
       int $0x80
   
   ```

   ```assembly
   (gdb) info reg
   eax            0x4f	79
   ecx            0xffb1	65457
   edx            0xffffffb1	-79
   ebx            0x4f	79
   
   ```

   此时，eax并没有变成负值，表明movsx并不是简单对最高位填1。而是提前根据寄存器中的值确定其中的正负，再通过这个正负来确定是否在最高位填1。下面这段代码也证明了这一点。==原来寄存器中的是正数最后就是正数，是负数最后就是负数。==

   ```assembly
   (gdb) 
   11	    movl $1, %eax
   (gdb) l
   6	    movw %cx, %bx
   7	    movsx %cx, %eax
   8	    movw $65457, %cx
   9	    movsx %cx, %edx
   10	
   11	    movl $1, %eax
   12	    movl $0, %ebx
   13	    int $0x80
   (gdb) info reg
   eax            0xffffffb1	-79
   ecx            0xffb1	65457
   edx            0xffffffb1	-79
   ebx            0xffb1	65457
   
   ```

   在二进制补码表示机器中，cx(16位)能表示的范围是-32768~32767。65457超过这个范围，与-79的二进制码相同，被认为是一个负数，所以movsx在移动时给最高位添加了一个1。无符号数也有正数，所有这个功能很重要。

### 7.2.6 在GNU汇编器中定义整数

.quad命令与.int一样可以定义一个或多个带符号整数值，但是为每个值分配8个字节。调试器中会当成32位字节来显示会出错，可以用

```
x/5gd &data
```

指令来显示。

```assembly
.section .data
data1:
    .int 1, -1, 463345, -333252322, 0
data2:
    .quad 1, -1, 463345, -333252322, 0

.section .text
.globl _start
_start:
    movl $1, %eax
    movl $0, %ebx
    int $0x80

```

内存为data1用32位分配4个字节。为data2分配8个字节。

```assembly
(gdb) x/5d &data1
0x804a000:	1	-1	463345	-333252322
0x804a010:	0
(gdb) x/5d &data2
0x804a014:	1	0	-1	-1
0x804a024:	463345
(gdb) x/20xb &data1
0x804a000:	0x01	0x00	0x00	0x00	0xff	0xff	0xff	0xff
0x804a008:	0xf1	0x11	0x07	0x00	0x1e	0xf9	0x22	0xec
0x804a010:	0x00	0x00	0x00	0x00
(gdb) x/40xb &data2
0x804a014:	0x01	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x804a01c:	0xff	0xff	0xff	0xff	0xff	0xff	0xff	0xff
0x804a024:	0xf1	0x11	0x07	0x00	0x00	0x00	0x00	0x00
0x804a02c:	0x1e	0xf9	0x22	0xec	0xff	0xff	0xff	0xff
0x804a034:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
(gdb) x/5gd &data2
0x804a014:	1	-1
0x804a024:	463345	-333252322
0x804a034:	0
```

## 7.3 SIMD整数

> Intel的单指令多数据(Single Instruction Multiple Data，SIMD)技术提供了定义整数的其它方式。SIMD架构使用打包的整数数据类型。<font color = red>打包的整数是能够表示多个整数值的一系列字节</font>。可以将字节看作一个整体，对它执行数学操作，并行地处理系列中的各个整数值。

### 7.3.1 MMX整数

> 多媒何事扩展(Multimedia Extension, MMX)技术是在奔腾MMX和奔腾2处理器中引入的，提供3种新的整数类型。

* 64位打包字节整数
* 64位打包字整数
* 64位打包双字整数

![image-20210508143721902](https://i.loli.net/2021/05/08/uz2GOB4yaAefojb.png)

MMX寄存器被映射到FPU寄存器，在使用任何MMX指令前请先保存好FPU寄存器的值。

### 7.3.2 传送MMX整数

```assembly
movq source, destination
```

```assembly
.section .data
values1:
    .int 1, -1
values2:
    .byte 0x10, 0x05, 0xff, 0x32, 0x47, 0xe4, 0x00, 0x01
.section .text
.globl _start
_start:
    movq values1, %mm0
    movq values2, %mm1
    movl $1, %ebx
    movl $0, %eax
    int $0x80

```

```assembly
Breakpoint 1, _start () at mmxtest.s:9
warning: Source file is more recent than executable.
9	    movq values1, %mm0
(gdb) s
10	    movq values2, %mm1
(gdb) s
11	    movl $1, %ebx
(gdb) p %mm0
A syntax error in expression, near `%mm0'.
(gdb) p $mm0
$1 = {uint64 = -4294967295, v2_int32 = {1, -1}, v4_int16 = {1, 0, -1, -1}, v8_int8 = {1, 0, 0, 0, -1, -1, -1, -1}}
(gdb) p $mm1
$2 = {uint64 = 72308588487312656, v2_int32 = {855573776, 16835655}, v4_int16 = {1296, 13055, -7097, 256}, v8_int8 = {16, 5, -1, 50, 71, -28, 0, 1}}
(gdb) x/2xw &values1
0x804a000:	0x00000001	0xffffffff
(gdb) x/4xh &values1
0x804a000:	0x0001	0x0000	0xffff	0xffff
(gdb) x/2dw &values1
0x804a000:	1	-1
(gdb) x/4dh &values1
0x804a000:	1	0	-1	-1
(gdb) x/8xb &values1
0x804a000:	0x01	0x00	0x00	0x00	0xff	0xff	0xff	0xff
(gdb) x/8db &values1
0x804a000:	1	0	0	0	-1	-1	-1	-1

```

可以看出打印mm0寄存器时，给你显示了不同位的结果。这里用的是int_32位。下面x打印也印证了这一点。mm1用的是byte，不用多说是8位。

### 7.3.3 SSE整数

流化SIMD扩展(Streaming SIMD Extension, SSE)技术提供用于处理打包数据的8个128位XMM寄存器(名为XMM0到XMM7)。SSE2技术(奔腾4处理器中引入的)提供4种额外的打包带符号整数数据类型：

* 128位打包字节整数(16字节)
* 128位打包字整数(8字)
* 128位打包双字整数(4双字)
* 128位打包四字整数(2四字)

![image-20210508183710512](https://i.loli.net/2021/05/08/9Qdw3J1sGnbRSr6.png)

### 7.3.4 传送SSE整数

```assembly
movqa source, destination #对准16字节边界的数据
movqu source, destination
```

```assembly
.section .data
values1:
    .int 1, -1, 0, 135246  #4个32位整数
values2:
    .quad 1, -1 #2个64位整数
.section .text
.globl _start
_start:
    movdqu values1, %xmm0
    movdqu values2, %xmm1
    movl $1, %eax
    movl $0, %ebx
    int $0x80

```

```assembly
Breakpoint 1, _start () at ssetest.s:9
9	    movdqu values1, %xmm0
(gdb) x/4dw &values1
0x804a000:	1	-1	0	135246
(gdb) x/2dg &values2
0x804a010:	1	-1
(gdb) x/4xw &values1
0x804a000:	0x00000001	0xffffffff	0x00000000	0x0002104e
(gdb) x/2xg &values2
0x804a010:	0x0000000000000001	0xffffffffffffffff
(gdb) s
10	    movdqu values2, %xmm1
(gdb) s
11	    movl $1, %eax
(gdb) p $xmm0
$1 = {v4_float = {1.40129846e-45, -nan(0x7fffff), 0, 1.89520012e-40}, v2_double = {-nan(0xfffff00000001), 2.8699144274488922e-309}, v16_int8 = {1, 0, 0, 0, 
    -1, -1, -1, -1, 0, 0, 0, 0, 78, 16, 2, 0}, v8_int16 = {1, 0, -1, -1, 0, 0, 4174, 2}, v4_int32 = {1, -1, 0, 135246}, v2_int64 = {-4294967295, 
    580877146914816}, uint128 = 10715292067404213048920514521726977}
(gdb) p $xmm1
$2 = {v4_float = {1.40129846e-45, 0, -nan(0x7fffff), -nan(0x7fffff)}, v2_double = {4.9406564584124654e-324, -nan(0xfffffffffffff)}, v16_int8 = {1, 0, 0, 0, 
    0, 0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1}, v8_int16 = {1, 0, 0, 0, -1, -1, -1, -1}, v4_int32 = {1, 0, -1, -1}, v2_int64 = {1, -1}, 
  uint128 = 340282366920938463444927863358058659841}

```



## 7.4 二进制编码的十进制

### 7.4.1 BCD是什么？

BCD用8位来表示一个十进制数。8位可以表示256个数，竟然只用来表法0~9。改为打包的BCD，4位表示一个十进制数。显然，这样也浪费了6个数，但是没办法了。

![image-20210507102711616](https://i.loli.net/2021/05/07/iCxjRAFGt2O7rZ4.png)

### 7.4.2 FPU BCD值

> FPU寄存器可以用于在FPU之内进行BCD数学运算操作。FPU包含8个80位寄存器(从ST0到ST7)，也可以使用它们保存80位BCD值。

![image-20210507103418279](https://i.loli.net/2021/05/07/RaSs2H9P63XKNoZ.png)



低9个字节保存BCD值，最高字节用于符号位。

### 7.4.3 传送BCD值

使用FBLD和FBSTP指令把80位打包BCD值加载到FPU寄存器中以及从FPU寄存器获取这些值。

```assembly
.section .data
data1:
    .byte 0x34, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
data2:
    .int 2

.section .text

.globl _start
_start:
    fbld data1 #加载到FPU, ST0引用FPU寄存器堆栈顶
    fimul data2  #ST0值与data2相乘
    fbstp data1 #送回
    
    movl $0, %ebx
    movl $1, %eax
    int $0x80

```

8个FPU寄存器的行为类似于内存中的堆栈区域，FBLD是压入，ST0引用位于堆栈顶部的寄存器，压入的值会存入ST0，原来的ST0会被加载到ST1中去。FBSTP是弹出。

```assembly
11	    fbld data1 #加载到FPU, ST0引用FPU寄存器堆栈顶
(gdb) x/10xb &data1
0x804a000:	0x34	0x12	0x00	0x00	0x00	0x00	0x00	0x00
0x804a008:	0x00	0x00
(gdb) x/x &data1
0x804a000:	0x34
(gdb) s
12	    fimul data2  #ST0值与data2相乘
(gdb) 
13	    fbstp data1 #送回
(gdb) 
15	    movl $0, %ebx
(gdb) x/10xb &data1
0x804a000:	0x68	0x24	0x00	0x00	0x00	0x00	0x00	0x00
0x804a008:	0x00	0x00
(gdb) x/x &data1
0x804a000:	0x68
(gdb) x/10xb &data1
0x804a000:	0x68	0x24	0x00	0x00	0x00	0x00	0x00	0x00
0x804a008:	0x00	0x00
(gdb) x/w &data1
0x804a000:	0x00002468

```

注意：内存显示反人类，低位在前。

## 7.5 浮点数

### 7.5.1 浮点数是什么

1. 浮点格式：浮点数表示与科学记数法相近。
2. 二进制浮点格式

![image-20210507205640705](https://i.loli.net/2021/05/07/4H5CQ26UNRJD3oE.png)

### 7.5.2 标准浮点数据类型

IEEE(institute of Electrical and Electronics Engineers)电气和电子工程师学会创建了IEEE标位754浮点格式。

![image-20210507205834239](https://i.loli.net/2021/05/07/9n8iauY16vbqKOV.png)

### 7.5.3 IA-32浮点值

![image-20210507205950008](https://i.loli.net/2021/05/07/U7eHINTmaCKpjDk.png)

### 7.5.5 传送浮点值

```assembly
.section .data
value1:
    .float 12.34
value2:
    .double 2353.631
value3:
    .int 65536
   
.section .bss
    .lcomm data, 8

.section .text
.globl _start
_start:
    flds value1 #把单精度浮点数加载到FPU寄存器堆栈中
    fldl value2 #把双精度浮点数加载到FPU寄存器堆栈中
    fstl data #获取FPU寄存器堆栈顶部的值，放入内存位置中
    movl $1, %eax
    movl $0, %ebx
    int $0x80

```

```assembly
Breakpoint 1, _start () at mfloattest.s:15
15	    flds value1 #把单精度浮点数加载到FPU寄存器堆栈中
(gdb) x/fw &value1
0x804a000:	12.3400002
(gdb) x/gf &value2
0x804a004:	2353.6309999999999
(gdb) n
16	    fldl value2 #把双精度浮点数加载到FPU寄存器堆栈中
(gdb) p $st0
$1 = 12.340000152587890625
(gdb) n
17	    fstl data #获取FPU寄存器堆栈顶部的值，放入内存位置中
(gdb) p $st0
$2 = 2353.63099999999985812
(gdb) n
18	    movl $1, %eax
(gdb) x/gf &data
0x804a010 <data>:	2353.6309999999999


```



IEEE754在内存中存储形式为：

| 数符 | 阶码(含阶符) | 尾数     |
| ---- | ------------ | -------- |
| sign | exponent     | fraction |

对于不同长度的浮点数，阶码与小数位分配的数理不一样：

| #        | 数符 | 阶码 | 尾数 | 总位数 | 偏移值 |
| -------- | ---- | ---- | ---- | ------ | ------ |
| 短实数   | 1    | 8    | 23   | 32     | 127    |
| 长实数   | 1    | 11   | 52   | 64     | 1023   |
| 临时实数 | 1    | 15   | 64   | 80     | 16383  |

```assembly
.section .data
value1:
    .float 13.375
value2:
    .double 2353.631
value3:
    .int 65536
   
.section .bss
    .lcomm data, 8

.section .text
.globl _start
_start:
    flds value1
    fldl value2
    fstl data
    movl $1, %eax
    movl $0, %ebx
    int $0x80

```

用13.375举例：

```assembly
(gdb) x/4xb &value1
0x804a000:	0x00	0x00	0x56	0x41
0100 0001 0101 0110 0000 0000 0000 0000 
0 1000 0010 1010 1100 0000 0000 0000 000
```

| 数符 | 阶码(含阶符) | 尾数                         |
| ---- | ------------ | ---------------------------- |
| sign | exponent     | fraction                     |
| 0    | 1000 0010    | 1010 1100 0000 0000 0000 000 |

$1101.011=>1.101 011 * 2^{11}$这里的$2^{11}$中的11是二进制，十进制3。

1. 数符：正数为0

2. 阶码：阶数+偏移量

   1. 阶数：移位的数字，3位。3的二进制是11。

   2. 偏移量：$2^{(e-1)} - 1$，e为阶码的位数，短实数为8。0111 1111

      0111 1111 + 11 = 1000 0010

3. 尾数：小数点后面的数101011

```assembly
0 1000 0010 1010 1100 0000 0000 0000 000
```

与调试结果相同。

### 7.5.6 使用预置的浮点值

![image-20210508090526520](https://i.loli.net/2021/05/08/wuC6QbOV8jrqPWs.png)

在浮点数据类型中，+0.0与-0.0是不同的，除法中产生不同的值(正无穷大与负无穷大)。

```assembly
section .data
.section .text
.globl _start
_start:
    fld1
    fldl2t
    fldl2e
    fldpi
    fldlg2
    fldln2
    fldz
    mov $1, %ebx
    mov $0, %eax
    int $0x80

```

```assembly
Breakpoint 1, _start () at fpuvals.s:5
warning: Source file is more recent than executable.
5	    fld1
(gdb) s
6	    fldl2t
(gdb) 
7	    fldl2e
(gdb) 
8	    fldpi
(gdb) 
9	    fldlg2
(gdb) 
10	    fldln2
(gdb) 
11	    fldz
(gdb) 
12	    mov $1, %ebx
(gdb) info all
.
.
.
st0            0	(raw 0x00000000000000000000)
st1            0.693147180559945309429	(raw 0x3ffeb17217f7d1cf79ac)
st2            0.301029995663981195226	(raw 0x3ffd9a209a84fbcff799)
st3            3.14159265358979323851	(raw 0x4000c90fdaa22168c235)
st4            1.44269504088896340739	(raw 0x3fffb8aa3b295c17f0bc)
st5            3.32192809488736234781	(raw 0x4000d49a784bcd1b8afe)
st6            1	(raw 0x3fff8000000000000000)
st7            0	(raw 0x00000000000000000000)
.
.
.
```

值的顺序和它们被存放到堆栈中的顺序是相反的。

### 7.5.7 SSE浮点数据类型

> SSE引入的8个128位XMM寄存器可以用其保存打包浮点数。

* 128位打包单精度浮点(SSE中)(4个单精度)
* 128位打包双精度浮点(SSE2中)(2个双精度)

![image-20210508190545925](https://i.loli.net/2021/05/08/OrYSwUmaN5z24ih.png)

### 7.5.8 传送SSE浮点值

IA-32指令集有打包单精度的SSE指令，也有打包双精度的SSE2指令。

1. SSE浮点值

   ![image-20210508191100591](https://i.loli.net/2021/05/08/fha6uD2KUxoqjiR.png)

   ```assembly
   .section .data
   value1: 
       .float 12.34, 2345.543, -3493.2, 0.44901
   value2:
       .float -5439.234, 32121.4, 1.0094, 0.000003
   .section .bss
       .lcomm data, 16
   
   .section .text
   .globl _start
   _start:
       movups value1, %xmm0
       movups value2, %xmm1
       movups %xmm0, %xmm2
       movups %xmm0, data
   
       movl $1, %eax
       movl $0, %ebx
       int $0x80
   
   ```

   

   ```assembly
   Breakpoint 1, _start () at ssefloat.s:12
   12	    movups value1, %xmm0
   (gdb) x/4fw &value1
   0x804a000:	12.3400002	2345.54297	-3493.19995	0.449010015
   (gdb) x/4fw &value2
   0x804a010:	-5439.23389	32121.4004	1.00940001	3.00000011e-06
   (gdb) s
   13	    movups value2, %xmm1
   (gdb) p %xmm1
   A syntax error in expression, near `%xmm1'.
   (gdb) p $xmm1
   $1 = {v4_float = {0, 0, 0, 0}, v2_double = {0, 0}, v16_int8 = {0 <repeats 16 times>}, v8_int16 = {0, 0, 0, 0, 0, 0, 0, 0}, v4_int32 = {0, 0, 0, 0}, 
     v2_int64 = {0, 0}, uint128 = 0}
   (gdb) p $xmm0
   $2 = {v4_float = {12.3400002, 2345.54297, -3493.19995, 0.449010015}, v2_double = {5.6204289471764299e+24, 1.0439462282443856e-05}, v16_int8 = {-92, 112, 69, 
       65, -80, -104, 18, 69, 51, 83, 90, -59, -92, -28, -27, 62}, v8_int16 = {28836, 16709, -26448, 17682, 21299, -15014, -7004, 16101}, v4_int32 = {
       1095069860, 1158846640, -983936205, 1055253668}, v2_int64 = {4977208420974555300, 4532279996355072819}, uint128 = 83605809163155287727927076236493680804}
   (gdb) s
   14	    movups %xmm0, %xmm2
   (gdb) p $xmm1
   $3 = {v4_float = {-5439.23389, 32121.4004, 1.00940001, 3.00000011e-06}, v2_double = {8.7452727745837517e+33, 3.4658329842889617e-47}, v16_int8 = {-33, -7, 
       -87, -59, -51, -14, -6, 70, 5, 52, -127, 63, -100, 83, 73, 54}, v8_int16 = {-1569, -14935, -3379, 18170, 13317, 16257, 21404, 13897}, v4_int32 = {
       -978716193, 1190851277, 1065432069, 910775196}, v2_int64 = {5114667292431088095, 3911749681893422085}, uint128 = 72159045262302707577450683077612927455}
   (gdb) s
   15	    movups %xmm0, data
   (gdb) p $xmm2
   $4 = {v4_float = {12.3400002, 2345.54297, -3493.19995, 0.449010015}, v2_double = {5.6204289471764299e+24, 1.0439462282443856e-05}, v16_int8 = {-92, 112, 69, 
       65, -80, -104, 18, 69, 51, 83, 90, -59, -92, -28, -27, 62}, v8_int16 = {28836, 16709, -26448, 17682, 21299, -15014, -7004, 16101}, v4_int32 = {
       1095069860, 1158846640, -983936205, 1055253668}, v2_int64 = {4977208420974555300, 4532279996355072819}, uint128 = 83605809163155287727927076236493680804}
   (gdb) s
   17	    movl $1, %eax
   (gdb) x/4fw &data
   0x804a020 <data>:	12.3400002	2345.54297	-3493.19995	0.449010015
   
   ```

2. SSE2浮点值

   ![image-20210508192428893](https://i.loli.net/2021/05/08/af5bsAS4ypltMmw.png)

```assembly
.section .data
value1:
    .double 12.34, 2345.543
value2:
    .double -5439.234, 32121.4
.section .bss
    .lcomm data, 16

.section .text
.globl _start
_start:
    movupd value1, %xmm0
    movupd value2, %xmm1
    movupd %xmm0, %xmm2
    movupd %xmm0, data
    movl $1, %eax
    movl $0, %ebx
    int $0x80

```

```assembly
Breakpoint 1, _start () at sse2float.s:12
warning: Source file is more recent than executable.
12	    movupd value1, %xmm0
(gdb) x/2fg &value1
0x804a000:	12.34	2345.5430000000001
(gdb) x/2fg &value2
0x804a010:	-5439.2340000000004	32121.400000000001
(gdb) s
13	    movupd value2, %xmm1
(gdb) s
14	    movupd %xmm0, %xmm2
(gdb) p $xmm0
$1 = {v4_float = {5.84860315e+35, 2.63562489, 1.79352231e-36, 5.07264233}, v2_double = {12.34, 2345.5430000000001}, v16_int8 = {-82, 71, -31, 122, 20, -82, 
    40, 64, 117, -109, 24, 4, 22, 83, -94, 64}, v8_int16 = {18350, 31457, -20972, 16424, -27787, 1048, 21270, 16546}, v4_int32 = {2061584302, 1076407828, 
    68719477, 1084379926}, v2_int64 = {4623136420479977390, 4657376318677619573}, uint128 = 85913429005601586953847513200535357358}
(gdb) p $xmm1
$2 = {v4_float = {-1.11704749e+24, -5.66396856, -1.58818684e-23, 6.98026705}, v2_double = {-5439.2340000000004, 32121.400000000001}, v16_int8 = {68, -117, 
    108, -25, 59, 63, -75, -64, -102, -103, -103, -103, 89, 94, -33, 64}, v8_int16 = {-29884, -6292, 16187, -16203, -26214, -26215, 24153, 16607}, 
  v4_int32 = {-412316860, -1061863621, -1717986918, 1088380505}, v2_int64 = {-4560669521124488380, 4674558677155944858}, 
  uint128 = 86230387575033986983375224144585853764}
(gdb) s
15	    movupd %xmm0, data
(gdb) p $xmm2
$3 = {v4_float = {5.84860315e+35, 2.63562489, 1.79352231e-36, 5.07264233}, v2_double = {12.34, 2345.5430000000001}, v16_int8 = {-82, 71, -31, 122, 20, -82, 
    40, 64, 117, -109, 24, 4, 22, 83, -94, 64}, v8_int16 = {18350, 31457, -20972, 16424, -27787, 1048, 21270, 16546}, v4_int32 = {2061584302, 1076407828, 
    68719477, 1084379926}, v2_int64 = {4623136420479977390, 4657376318677619573}, uint128 = 85913429005601586953847513200535357358}
(gdb) s
16	    movl $1, %eax
(gdb) x/16b &data
0x804a020 <data>:	-82	71	-31	122	20	-82	40	64
0x804a028 <data+8>:	117	-109	24	4	22	83	-94	64
(gdb) x/16b &value1
0x804a000:	-82	71	-31	122	20	-82	40	64
0x804a008:	117	-109	24	4	22	83	-94	64
(gdb) x/16xb &value1
0x804a000:	0xae	0x47	0xe1	0x7a	0x14	0xae	0x28	0x40
0x804a008:	0x75	0x93	0x18	0x04	0x16	0x53	0xa2	0x40
(gdb) x/16xb &data
0x804a020 <data>:	0xae	0x47	0xe1	0x7a	0x14	0xae	0x28	0x40
0x804a028 <data+8>:	0x75	0x93	0x18	0x04	0x16	0x53	0xa2	0x40
(gdb) x/2fg &data
0x804a020 <data>:	12.34	2345.5430000000001
(gdb) x/2fg &value1
0x804a000:	12.34	2345.5430000000001

```

3. SSE3指令

   奔腾4上有了SSE3技术，添加了3个附加指令来帮助传送在这个内存位置的两个值 。

   ![image-20210508194922505](https://i.loli.net/2021/05/08/ObIjt6X8BENg4Do.png)

## 7.6 转换

### 7.6.1 转换指令

![image-20210508195418995](https://i.loli.net/2021/05/08/p6M9zG1qAhDkJxX.png)

源值可以从内存位置、MMX寄存器(64位值)或者XMM寄存器(对于64位或者128位值)获得。目标寄存器可以是MMX，也可以是XMM寄存器。截断指令自动执行向零方向舍入，其它指令就会由XMM MXCSR寄存器的13位和14位控制进行舍入，这些位确定向上还是向下舍。

```assembly
.section .data
value1:
    .float 1.25, 124.79, 200.0, -312.5
value2:
    .int 1, -435, 0, -25 
.section .bss
data1:
    .lcomm data, 16
.section .text
.globl _start
_start:
    cvtps2dq value1, %xmm0 #无截断v4_int32 = {1, 125, 200, -312}
    cvttps2dq value1, %xmm1 #有截断v4_int32 = {1, 124, 200, -312}
    cvtdq2ps value2, %xmm2 #无截断
    movdqu %xmm0, data 

    movl $1, %eax
    movl $0, %ebx
    int $0x80

```

```assembly
Breakpoint 1, _start () at convtest.s:12
12	    cvtps2dq value1, %xmm0
(gdb) x/16xb &data
0x804a020 <data>:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x804a028 <data+8>:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
(gdb) x/16xb &data1
0x804a020 <data>:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x804a028 <data+8>:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
(gdb) x/4fw &value1
0x804a000:	1.25	124.790001	200	-312.5
(gdb) x/4fg &value2
0x804a010:	-nan(0xffe4d00000001)	-nan(0xfffe700000000)
0x804a020 <data>:	0	0
(gdb) x/4dw &value2
0x804a010:	1	-435	0	-25
(gdb) s
13	    cvttps2dq value1, %xmm1
(gdb) p $xmm0
$1 = {v4_float = {1.40129846e-45, 1.75162308e-43, 2.80259693e-43, -nan(0x7ffec8)}, v2_double = {2.6524947387115311e-312, -nan(0xffec8000000c8)}, v16_int8 = {
    1, 0, 0, 0, 125, 0, 0, 0, -56, 0, 0, 0, -56, -2, -1, -1}, v8_int16 = {1, 0, 125, 0, 200, 0, -312, -1}, v4_int32 = {1, 125, 200, -312}, v2_int64 = {
    536870912001, -1340029796152}, uint128 = 340282342201751762702250093524836941825}
(gdb) s
14	    cvtdq2ps value2, %xmm2
(gdb) p $xmm1
$2 = {v4_float = {1.40129846e-45, 1.7376101e-43, 2.80259693e-43, -nan(0x7ffec8)}, v2_double = {2.6312747808018783e-312, -nan(0xffec8000000c8)}, v16_int8 = {
    1, 0, 0, 0, 124, 0, 0, 0, -56, 0, 0, 0, -56, -2, -1, -1}, v8_int16 = {1, 0, 124, 0, 200, 0, -312, -1}, v4_int32 = {1, 124, 200, -312}, v2_int64 = {
    532575944705, -1340029796152}, uint128 = 340282342201751762702250093520541974529}
(gdb) s
15	    movdqu %xmm0, data
(gdb) p $xmm2
$3 = {v4_float = {1, -435, 0, -25}, v2_double = {-7.3498756827903427e+18, -805306368}, v16_int8 = {0, 0, -128, 63, 0, -128, -39, -61, 0, 0, 0, 0, 0, 0, -56, 
    -63}, v8_int16 = {0, 16256, -32768, -15399, 0, 0, 0, -15928}, v4_int32 = {1065353216, -1009156096, 0, -1043857408}, v2_int64 = {-4334292427813683200, 
    -4483333429047328768}, uint128 = 257579462558195729010253313545846390784}
(gdb) s
17	    movl $1, %eax
(gdb) x/4d &data
0x804a020 <data>:	1	125	200	-312

```

<b><font color = red size>初步推测无截断的是四舍五入：</font></b>

```assembly
Reading symbols from ./test...done.
(gdb) l
1	.section .data
2	value1:
3	    .float 1.3, 1.4, 1.5, 1.6
4	value2:
5	    .int 1, -435, 0, -25
6	.section .bss
7	data1:
8	    .lcomm data, 16
9	.section .text
10	.globl _start
(gdb) l
11	_start:
12	    cvtps2dq value1, %xmm0
13	    cvttps2dq value1, %xmm1
14	    cvtdq2ps value2, %xmm2
15	    movdqu %xmm0, data
16	
17	    movl $1, %eax
18	    movl $0, %ebx
19	    int $0x80
20	
(gdb) b *_start
Breakpoint 1 at 0x804814b: file convtest.s, line 12.
(gdb) r
Starting program: /home/zs/Assembly/7/6/2/test 

Breakpoint 1, _start () at convtest.s:12
12	    cvtps2dq value1, %xmm0
(gdb) s
13	    cvttps2dq value1, %xmm1
(gdb) 
14	    cvtdq2ps value2, %xmm2
(gdb) p $xmm0
$1 = {v4_float = {1.40129846e-45, 1.40129846e-45, 2.80259693e-45, 2.80259693e-45}, v2_double = {2.121995791459338e-314, 4.2439915829186759e-314}, 
  v16_int8 = {1, 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0}, v8_int16 = {1, 0, 1, 0, 2, 0, 2, 0}, v4_int32 = {1, 1, 2, 2}, v2_int64 = {4294967297, 
    8589934594}, uint128 = 158456325065422163338801971201}
(gdb) p $xmm1
$2 = {v4_float = {1.40129846e-45, 1.40129846e-45, 1.40129846e-45, 1.40129846e-45}, v2_double = {2.121995791459338e-314, 2.121995791459338e-314}, v16_int8 = {
    1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0}, v8_int16 = {1, 0, 1, 0, 1, 0, 1, 0}, v4_int32 = {1, 1, 1, 1}, v2_int64 = {4294967297, 4294967297}, 
  uint128 = 79228162532711081671548469249}

```

# 第八章：基本数学功能

## 8.1 整数运算

### 8.1.1 加法

1. ADD指令

```assembly
.section .data
data:
    .int 40
.section .text
.globl _start
_start:
    movl $0, %eax
    movl $0, %ebx
    movl $0, %ecx
    movb $20, %al 
    addb $10, %al 
    movsx %al, %eax
    movw $100, %cx 
    addw %cx, %bx 
    movsx %bx, %ebx
    movl $100, %edx
    addl %edx, %edx
    addl data, %eax
    addl %eax, data
    movl $1, %eax
    movl $0, %ebx
    int $0x80

```

```assembly
20	    movl $1, %eax
(gdb) info reg
eax            0x46	70
ecx            0x64	100
edx            0xc8	200
ebx            0x64	100
esp            0xffffd130	0xffffd130
ebp            0x0	0x0
esi            0xffffd13c	-11972
edi            0x804814b	134512971
eip            0x804817e	0x804817e <_start+51>
eflags         0x202	[ IF ]
cs             0x23	35
ss             0x2b	43
ds             0x2b	43
es             0x2b	43
fs             0x0	0
gs             0x63	99
(gdb) x/d &data
0x804a000:	110

```

无符号的加减与有符号的加减在补码中没有区别，结果都不会错。<b>使用补码的优势在于可以使用相同的硬件执行带符号和无符号整数的加法</b>

```assembly
.section .data
data:
    .int -40 
.section .text
.globl _start
_start:
    movl $-10, %eax
    movl $-200, %ebx
    movl $80, %ecx
#    movb $20, %al 
#    addb $10, %al 
#    movsx %al, %eax
#    movw $100, %cx 
#    addw %cx, %bx 
#    movsx %bx, %ebx
#    movl $100, %edx
#    addl %edx, %edx
    addl data, %eax
#    addl %eax, data
    addl %ecx, %eax
    addl %ebx, %eax
    addl %eax, data
    addl $210, data

    movl $1, %eax
    movl $0, %ebx
    int $0x80

```



```assembly
eax            0xffffff56	-170
ecx            0x50	80
edx            0xf7fe5970	-134325904
ebx            0xffffff38	-200
esp            0xffffd130	0xffffd130
ebp            0x0	0x0
esi            0xffffd13c	-11972
edi            0x804814b	134512971
eip            0x8048174	0x8048174 <_start+41>
eflags         0x257	[ CF PF AF ZF IF ]
cs             0x23	35
ss             0x2b	43
ds             0x2b	43
es             0x2b	43
fs             0x0	0
gs             0x63	99
(gdb) x/d &data
0x804a000:	0

```

ADD指令对所有的带符号数执行了正确的加法操作。

2. 检测进位或者溢出情况

   无符号数产生进位，有符号数产生溢出

   ```assembly
   .section .data
   .section .text
   .globl _start
   _start:
       movl $0, %ebx
       movb $190, %bl 
       movb $100, %al 
       addb %al, %bl #产生了进位CF = 1
       jc over
       movl $1, %eax
       int $0x80
   over:
       movl $1, %eax
       movl $0, %ebx
       int $0x80
   
   ```

   ```assembly
   Breakpoint 1, _start () at addtest3.s:5
   5	    movl $0, %ebx
   (gdb) s
   6	    movb $190, %bl
   (gdb) 
   7	    movb $100, %al
   (gdb) 
   8	    addb %al, %bl
   (gdb) 
   9	    jc over
   (gdb) p $eflags
   $1 = [ CF PF AF IF ]
   (gdb) p/t $bl
   $1 = 100010
   (gdb) p $bl
   $2 = 34
   
   ```

   <font color = blue>只有进位没有溢出。</font>

   ```
   190: 1011 1110
   100: 0110 0100
   ----------------
   34:	 0010 0010
   ```

   

   ```assembly
   .section .data
   output:
       .asciz "The result is %d\n"
   
   .section .text
   .globl _start
   _start:
       movl $-1590876934, %ebx
       movl $-1259230143, %eax
   # -2147483648~2147483647
       addl %eax, %ebx  #结果超过可表示范围
       jo over
       pushl %ebx
       pushl $output
       call printf
       add $8, %esp
       pushl $0
       call exit
   
   over:   
       pushl $0
       pushl $output
       call printf
       add $8, %esp
       pushl $0
       call exit
   
   ```

   ```assembly
   Breakpoint 1, _start () at addtest4.s:8
   warning: Source file is more recent than executable.
   8	    movl $-1590876934, %ebx
   (gdb) s
   9	    movl $-1259230143, %eax
   (gdb) 
   10	# -2147483648~2147483647
   (gdb) 
   11	    addl %eax, %ebx
   (gdb) 
   20	over:   
   (gdb) p $eflags
   $1 = [ CF IF OF ]
   
   ```

   从调试可以得出，它既产生了溢出，也产生了进位。这时，就要由程序员自己去决定到是无符号的进位还是有符号的溢出！有符号数只有在做运算的时候才会有用，无符号的出现省去了减法，对于机器来说，有符号与无符号都是二进制码，没有区别，同样的二进制码，程序员把它当作什么，这才是重要的。

   <font color = blue>只有溢出没有进位。</font>

   ```assembly
   Breakpoint 1, _start () at addtest3.s:7
   7	    movl $0, %ebx
   (gdb) s
   8	    movb $127, %bl
   (gdb) 
   9	    movb $1, %al
   (gdb) 
   11	    addb %al, %bl
   (gdb) 
   12	    jc over
   (gdb) p $eflags
   $1 = [ AF SF IF OF ]
   
   ```

3. ADC指令

   处理非常大的数时会用到这个指令。对于比较大的数，一个32位寄存器不够用，要用两个，那低位的32位相加时可能会产生进位。这个进位怎么加到高位寄存器中，ADC指令会抓到这个进位，并加到最后的结果中。

   ```assembly
   adc source, destination
   ```

   ```assembly
   .section .data
   data1:
       .quad 7252051615
   data2:
       .quad 5732348928
   output:
       .asciz "The result is %qd\n"
   .section .text
   .globl _start
   _start:
       movl data1, %ebx
       movl data1 + 4, %eax
       movl data2, %edx
       movl data2 + 4, %edx
       addl %ebx, %edx
       adcl %eax, %ecx
       pushl %ecx
       pushl %edx
       pushl $output
       call printf
       addl $12, %esp
       pushl $0
       call exit
   
   ```

   ADCL指令执行两个高位寄存器的加法操作，并且加上进位标志。

   ```assembly
   The result is 12984400543
   ```

   ```assembly
   Reading symbols from ./test...done.
   (gdb) l
   1	.section .data
   2	data1:
   3	    .quad -7252051615
   4	data2:
   5	    .quad 5732348928
   6	output:
   7	    .asciz "The result is %qd\n"
   8	.section .text
   9	.globl _start
   10	_start:
   (gdb) b *_start
   Breakpoint 1 at 0x80481f0: file adctest.s, line 11.
   (gdb) r
   Starting program: /home/zs/Assembly/8/1/3/test 
   
   Breakpoint 1, _start () at adctest.s:11
   11	    movl data1, %ebx
   (gdb) s
   12	    movl data1 + 4, %eax
   (gdb) s
   13	    movl data2, %edx
   (gdb) s
   14	    movl data2 + 4, %ecx
   (gdb) s
   15	    addl %ebx, %edx
   (gdb) 
   16	    adcl %eax, %ecx
   (gdb) s
   17	    pushl %ecx
   (gdb) s
   18	    pushl %edx
   (gdb) s
   19	    pushl $output
   (gdb) s
   20	    call printf
   (gdb) s
   0xf7e2d430 in printf () from /lib/i386-linux-gnu/libc.so.6
   (gdb) s
   Single stepping until exit from function printf,
   which has no line number information.
   The result is -1519702687
   
   ```

   书上写出："可以使用ADC指令执行两个无符号或者带符号整数值的加法"，实验证明两个符号不同也可以，不管是什么数（有符号与无符号），对于二进制补码，相加是不会出现问题的。

### 8.1.2 减法

1. sub指令

   ```assembly
   sub source, destination
   ```

   destination = destination - source

   请记得sub指令中操作数的顺序，与Intel语法不同。

2. 减法操作中的进位和溢出

   ```assembly
   .section .text
   .globl _start
   _start:
       movl $5, %eax
       movl $2, %ebx
       subl %eax, %ebx
       jc under
       movl $1, %eax
       int $0x80
   under:
       movl $1, %eax
       movl $0, %ebx
       int $0x80
   
   ```

   

   ```assembly
   Breakpoint 1 at 0x804814b: file subtest2.s, line 4.
   (gdb) r
   Starting program: /home/zs/Assembly/8/2/2/test 
   
   Breakpoint 1, _start () at subtest2.s:4
   4	    movl $5, %eax
   (gdb) s
   5	    movl $2, %ebx
   (gdb) 
   6	    subl %eax, %ebx
   (gdb) 
   7	    jc under
   (gdb) p $eflags
   $1 = [ CF AF SF IF ]
   (gdb) s
   11	    movl $1, %eax
   (gdb) 
   12	    movl $0, %ebx
   (gdb) 
   
   ```

   对于有符号数而言，其产生了进位，对于无符号数而言，其没有产生溢出。

   ```assembly
   .section .data
   output:
       .asciz "The result is %d\n"
   .section .text
   .globl _start
   _start:
       movl $-1590876934, %ebx
       movl $1259230143, %eax
       subl %eax, %ebx
       jo over
       pushl %ebx
       pushl $output
       call printf
       add $8, %esp
       pushl $0
       call exit
   
   over:
       pushl $0
       pushl $output
       call printf
       add $8, %esp
       pushl $0
       call exit
   
   ```

   

   ```assembly
   Breakpoint 1, _start () at subtest3.s:7
   7	    movl $-1590876934, %ebx
   (gdb) s
   8	    movl $1259230143, %eax
   (gdb) s
   9	    subl %eax, %ebx
   (gdb) 
   10	    jo over
   (gdb) 
   19	    pushl $0
   (gdb) p $eflags
   $1 = [ AF IF OF ]
   
   ```

   既产生了溢出，也产生了进位。

3. sbb指令

   ```assembly
.section .data
   data1:
       .quad 7252051615
   data2:
       .quad 5732348928
   
   output:
       .asciz "The value is %d\n"
   .section .text
   
   .globl _start
   _start:
       movl data1, %ebx
       movl data1 + 4, %eax
       movl data2, %edx
       movl data2 + 4, %ecx
       subl %ebx, %edx
       sbbl %eax, %ecx
       pushl %ecx
       pushl %edx
       pushl $output
       call printf
       addl $12, %esp
       pushl $0
       call exit
   
   ```
   
   ```
   The value is -1519702687
   ```
   
   书上说：“可以使用进位情况帮助执行大的无符号整数值的减法操作”，但是两个有符号的值也能正常运行出正确结果（显然与无符号数相减没区别），两个符号不同的值运算会出错。减法运算可能用了另一种机制来实现，而不是单纯的转为加法。
   

<font size = 5 color = red>综上，sbb用在两个无符号数相减，其余用adc。</font>

### 8.1.3 递增和递减

```assembly
inc destination
dec destination
```

主要用于无符号整数，计算机不会把32位的0xffffffff当作-1，只会当作4294967295。

### 8.1.4 乘法

1. 使用MUL进行无符号整数乘法

   ```assembly
   mul source
   ```

   目标位置是EDX:EAX中的一部分，且是源操作数的两倍长度。所以源值不能是立即数，如果源值是8位，就要用AX(16位)，源值是16位用DX:AX保存，源值是32位用EDX:EAX保存。使用时注意保存EDX中原有的值。

   ![image-20210510102141223](https://i.loli.net/2021/05/10/cJdIxzmHrpEYNyi.png)

2. 范例

   ```assembly
   .section .data
   data1:
       .int 315814
   data2:
       .int 165432
   result:
       .quad 0
   
   output:
       .asciz "The result is %qd\n"
   
   .section .text
   .globl _start
   _start:
       movl data1, %eax
       mull data2
       movl %eax, result
       movl %edx, result + 4 
   
       pushl %edx
       pushl %eax
       pushl $output
       call printf
       addl $12, %esp
       pushl $0
       call exit
   
   ```

   ```
   The result is 52245741648
   ```

   

   ```assembly
   Breakpoint 1, _start () at multest.s:15
   15	    movl data1, %eax
   (gdb) s
   16	    mull data2
   (gdb) s
   17	    movl %eax, result
   (gdb) s
   18	    movl %edx, result + 4
   (gdb) s
   20	    pushl %edx
   (gdb) x/2w &result
   0x804a01c:	706134096	12
   (gdb) x/2xw &result
   0x804a01c:	0x2a16c050	0x0000000c
   (gdb) 
   
   ```

   ```assembly
   .section .data
   data1:
       .short 30000
   data2:
       .short 30000
   result:
       .quad 0
   
   output:
       .asciz "The result is %d\n"
   
   .section .text
   .globl _start
   _start:
       movw data1, %ax 
       mulw data2
       movw %ax, result
       movw %dx, result + 2 
   
       pushw %dx 
       pushw %ax 
       pushl $output
       call printf
       addl $8, %esp
       pushl $0
       call exit
   
   ```

   ```
   The result is 900000000
   ```

3. 使用IMUL进行带符号整数乘法

   > IMUL可以用于带符号和无符号整数，但是必须小心结果不使用目标的最高有效位。对于较大的值，只对带符号整数是合法的。

   ```assembly
   imul source #与mul相同
   imul source, destination #source可以寄存器或内存中的值，destination只能是16位或者32位通用寄存器，结果被限制为单一目标寄存器的长度，注意不要溢出 source * destination = destination
   imul multiplier, source, destination#第一个是立即值，源与目标与上面的指令操作一样
   ```

4. 范例

   ```assembly
   .section .data
   value1:
       .int 10
   value2:
       .int -35 
   value3:
       .int 400 
   .section .text
   .globl _start
   _start:
       movl value1, %ebx 
       movl value2, %ecx
       imull %ebx, %ecx
       movl value3, %edx
       imull $2, %edx, %eax
   
       movl $0, %ebx
       movl $1, %eax
       int $0x80
   
   ```

   ```assembly
   Breakpoint 1, _start () at imultest.s:11
   11	    movl value1, %ebx
   (gdb) s
   12	    movl value2, %ecx
   (gdb) 
   13	    imull %ebx, %ecx
   (gdb) 
   14	    movl value3, %edx
   (gdb) 
   15	    imull $2, %edx, %eax
   (gdb) 
   17	    movl $0, %ebx
   (gdb) 
   18	    movl $1, %eax
   (gdb) info reg
   eax            0x320	800
   ecx            0xfffffea2	-350
   edx            0x190	400
   ebx            0x0	0
   esp            0xffffd0e0	0xffffd0e0
   ebp            0x0	0x0
   esi            0xffffd0ec	-12052
   edi            0x804814b	134512971
   eip            0x8048168	0x8048168 <_start+29>
   eflags         0x202	[ IF ]
   cs             0x23	35
   ss             0x2b	43
   ds             0x2b	43
   es             0x2b	43
   fs             0x0	0
   gs             0x63	99
   
   ```

5. 检查溢出

   从目前本人经验来看，有运算就会更改EFLAGS寄存器。

   ```assembly
   .section .text
   .globl _start
   _start:
       movw $680, %ax 
       movw $100, %cx 
       imulw %cx 
       jo over
       movl $1, %eax
       movl $0, %ebx
       int $0x80
   
   over:
       movl $1, %eax
       movl $1, %ebx
       int $0x80
   
   ```

### 8.1.5 除法

1. 无符号除法

   ```assembly
   div divisor
   ```

   divisor可以是8位、16位、或者32位寄存器的内存中的值。被除数是AX、DX:AX、EDX:EAX中的值。且与乘法原理相似，被除数要比除数大一倍。

   ![image-20210510182253362](https://i.loli.net/2021/05/10/wgXy1TcYZO6CzJp.png)

   ```assembly
   .section .data
   dividend:
       .quad 8335
   divisor:
       .int 25
   quotient:
       .int 0
   remainder:
       .int 0
   output:
       .asciz "The quotient is %d, and the remainder is %d.\n"
   
   .section .text
   .globl _start
   _start:
       movl dividend, %eax #8字节整数低位
       movl dividend + 4, %edx #8字节整数高位
       divl divisor
       movl %eax, quotient #商
       movl %edx, remainder #余数
       pushl quotient
       pushl remainder
       pushl $output
       call printf
       add $12, %esp
       pushl $0
       call exit
   
   ```

   ```
   The quotient is 10, and the remainder is 333.
   ```

2. 带符号除法

   ```assembly
   idiv divisor
   ```

   被除数与除数和无符号除法一样。余数的符号与被除数相同。

   ```assembly
   .section .data
   value1:
       .int -150
   value2:
       .short 14
   output:
       .asciz "The quotient is %d, and the remainder is %d\n"
   .section .text
   .globl _start
   _start:
       movw value1, %ax 
       movw value1 + 2, %dx 
       idivw value2
       movsx %ax, %eax
       movsx %dx, %edx
       pushl %eax
       pushl %edx
       pushl $output
       call printf
       addl $12, %esp
       pushl $0
       call exit
   
   ```

   ```assembly
   The quotient is -10, and the remainder is -10
   ```

3. 检查除法错误

   不要把除数设置为0。

## 8.2 移位指令

### 8.2.1 移位乘法

SAL（向左算术移位），SHL（向左逻辑移位）

```assembly
sal destination #把dstination中的值左移一位
sal %cl, destination #把dstination中的值左移CL中的值
sal shhifter, destination #把dstination中的值左移shifter位
```

移位产生的数会放在进位标志中。

![image-20210510185541817](https://i.loli.net/2021/05/10/fiyCjaNB1kIY4op.png)

### 8.2.2 移位除法

SHR用于对无符号整数进行移位，进位直接清空。

SAR根据整数的符号位决进位清空还是置1。

移位产生的位也会先放入进位标志中。

![image-20210510190009642](https://i.loli.net/2021/05/10/B2pMdES6jvGJquY.png)



### 8.2.3 循环移位

![image-20210510190258901](https://i.loli.net/2021/05/10/mO97ZNKJIlALpoX.png)

 ## 8.4 逻辑操作

### 8.4.1 布尔逻辑

* AND
* OR
* XOR

```assembly
and source, destination
```

* NOT

```assembly
not destination
```

```assembly
.section .data
value:
    .byte 5
output:
    .asciz "The value is %d.\n"
.section .text
.globl _start
_start:
    movl $0, %eax
    and value, %al 
    movsx %al, %eax
    pushl %eax
    pushl $output
    call printf
    addl $8, %esp
    pushl $0
    call exit

```

### 8.4.2 位测试

```assembly
test source, destination
```

常用来检测EFLAGS中的某一位是否为1。原理与AND没区别。

# 第十章：处理字符串

## 10.1 传送字符串

> 内存位置到内存位置

### 10.1.1 MOVS指令

```assembly
movsb 传送单一字节
movsw 传送一个字
movsl 传送双字
```

隐含源操作数为ESI寄存器，隐含目标操作数为EDI寄存器。ESI与EDI寄存器都是指针，分别指向源字符串内存位置与目标字符串内存位置。

两种方式加载ESI与EDI寄存器。

```assembly
movl $output, %edi
leal output, %edi
```

1. 基本使用

```assembly
.section .data
value1:
    .ascii "This is a test string.\n"
.section .bss
    .lcomm output, 23
.section .text
.globl _start
_start:
    leal value1, %esi
    leal output, %edi
    movsb
    movsw
    movsl
    
    movl $1, %eax
    movl $0, %eax
    int $0x80

```

```assembly
warning: Source file is more recent than executable.
9	    leal value1, %esi
(gdb) s
10	    leal output, %edi
(gdb) s
11	    movsb
(gdb) 
12	    movsw
(gdb) x/s &output
0x804a018 <output>:	"T"
(gdb) s
13	    movsl
(gdb) x/s &output
0x804a018 <output>:	"Thi"
(gdb) s
15	    movl $1, %eax
(gdb) x/s &output
0x804a018 <output>:	"This is"

```

2. 移动顺序问题

   每一次的movs操作之后，edi与esi寄存器都会自动改变到下一个位置。那到底esi与edi寄存器是递增还是递减呢？取决于EFLAGS寄存器中的DF标志。有两个指令可以设置DF标志。

* CLD（DF清零）：ESI与EDI递增
* STD（DF被设置）：ESI与EDI递减

```assembly
.section .data
value1:
    .ascii "This is a test string.\n"
.section .bss
    .lcomm output, 23
.section .text
.globl _start
_start:
    leal value1 + 22, %esi
    leal output + 22, %edi
    std 
    movsb
    movsw
    movsl
    
    movl $1, %eax
    movl $0, %eax
    int $0x80

```

![image-20210512134906427](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20210512134906427.png)

​	图中来看movsl只复制了4个字节，因为尽管ESI前移了，但是movs指令一次还是会向后取值。如果前一个操作短，后一个操作长，就会覆盖复制。解决办法是每条指令相同长度。

3. 可以使用循环来复制。

```assembly
.section .data
value1:
    .ascii "This is a test string.\n"
value2:
    .ascii "sentense:%s"
.section .bss
    .lcomm output, 23
.section .text
.globl _start
_start:
    leal value1, %esi
    leal output, %edi
    movl $23, %ecx
    cld 
loop1:
    movsb
    loop loop1
    
    movl $1, %eax
    movl $0, %eax
    int $0x80

```

### 10.1.2 REP前缀

```assembly
rep movsx #x表示不同的字节数
```

rep用于按照特定次数重复执行字符串指令，由ECX寄存器中的值进行确定，自动递减，直到为0。为什么叫前缀，在这本书中，未执行的代码是前面的。

```assembly
.section .data
value1:
    .ascii "This is a test string.\n"
.section .bss
    .lcomm output, 23
.section .text
.globl _start
_start:
    leal value1, %esi
    leal output, %edi
    movl $23, %ecx
    cld 
    rep movsb
    movl $0, %ebx
    movl $1, %eax
    int $0x80

```

单步执行时其只占一个步骤。

```assembly
Starting program: /home/zs/Assembly/10/1/2/1/test 

Breakpoint 1, _start () at reptest1.s:9
9	    leal value1, %esi
(gdb) s
10	    leal output, %edi
(gdb) 
11	    movl $23, %ecx
(gdb) 
12	    cld 
(gdb) 
13	    rep movsb
(gdb) 
14	    movl $0, %ebx
```

2. 逐块地传送字符串

```assembly
.section .data
value1:
    .ascii "This is a test string.\n"
value2:
    .ascii "Oops"
.section .bss
    .lcomm output, 23
.section .text
.globl _start
_start:
    leal value1, %esi
    leal output, %edi
    movl $6, %ecx
    cld 
    rep movsl #一次传送4字节，共24字节
    movl $0, %ebx
    movl $1, %eax
    int $0x80

```



```assembly
Breakpoint 1 at 0x804814b: file reptest1.s, line 11.
(gdb) r
Starting program: /home/zs/Assembly/10/1/2/2/test 

Breakpoint 1, _start () at reptest1.s:11
11	    leal value1, %esi
(gdb) s
12	    leal output, %edi
(gdb) s
13	    movl $6, %ecx
(gdb) 
14	    cld 
(gdb) 
15	    rep movsl
(gdb) 
16	    movl $0, %ebx
(gdb) x/s &output
0x804a020 <output>:	"This is a test string.\nO"

```

调试可以看出，多了一个字节。

```assembly
.section .data
string1:
    .asciz "This is a test of the conversion program!\n"
length:
    .int 43
divisor:
    .int 4
.section .bss
    .lcomm buffer, 23
.section .text
.globl _start
_start:
    leal string1, %esi
    leal buffer, %edi
    movl length, %ecx
    shrl $2, %ecx #右移两位，除4，得到10给ecx

    cld 
    rep movsl #每次移动4字节，移动10次
    movl length, %ecx
    andl $3, %ecx #把最后3个加上
    rep movsb

    movl $0, %ebx
    movl $1, %eax
    int $0x80

```

这种方式实现了一个自动处理。

4. 按照相反顺序传送字符串

   ```assembly
   .section .data
   string:
       .ascii "This is a test string.\n"
   .section .bss
       .lcomm buffer, 24
   .section .text
   .globl _start
   _start:
       leal string + 22, %esi
       leal buffer + 22, %edi
       movl $23, %ecx
       std 
       rep movsb
   
       movl $0, %ebx
       movl $1, %eax
       int $0x80
   
   ```

   ```assembly
   Breakpoint 1, _start () at reptestr.s:9
   9	    leal string + 22, %esi
   (gdb) s
   10	    leal buffer + 22, %edi
   (gdb) 
   11	    movl $23, %ecx
   (gdb) 
   12	    std
   (gdb) 
   13	    rep movsb
   (gdb) 
   15	    movl $0, %ebx
   (gdb) x/s &buffer
   0x804a018 <buffer>:	"This is a test string.\n"
   ```

### 10.1.3 其他rep指令

监视零标志ZF状态的REP指令。

![image-20210512150653915](C:\Users\31787\AppData\Roaming\Typora\typora-user-images\image-20210512150653915.png)

## 10.2 存储和加载字符串

> 内存位置到寄存器，寄存器到内存位置

### 10.2.1 LODS指令

```assembly
lodsb 把ESI寄存器指向的一个字符加载到AL寄存器中，ESI自动递增或递减，DF标志决定
lodsw 把一个字加载到AX寄存器中
lodsl 把双字加载到EAX寄存器中
```

### 10.2.2 STOS指令

```assembly
stosb 把AL寄存器中存的一个字节放到EDI指向的内存位置，之后EDI递增或递减，DF标志决定
stosw 把AX寄存器的一个字
stosl 把EAX寄存器中的双字
```

```assembly
.section .data
space:
    .ascii " " 
.section .bss
    .lcomm buffer, 256 
.section .text
.globl _start
_start: 
    leal space, %esi
    leal buffer, %edi
    movl $256, %ecx
    cld 
    lodsb
    rep stosb
    
    movl $1, %ebx
    movl $0, %eax
#复制了256个空格
```

### 10.2.3 构建自己的字符串函数

```assembly
.section .data
string1:
    .asciz "This is a TEST,  of the conversion program!\n"
length:
    .int 43

.section .text
.globl _start
_start:
    leal string1, %esi
    leal string1, %edi
    movl length, %ecx

    cld 
loop1:
    lodsb
    cmpb $'a', %al #比较
    jl skip #有符号判断，小于则跳转
    cmpb $'z', %al 
    jg skip #大于则跳转
    subb $0x20, %al 
skip:
    stosb #拷贝，指向下一个
    loop loop1
end:
    pushl $string1
    call printf
    addl $4, %esp
    pushl $0
    call exit

```

```assembly
THIS IS A TEST,  OF THE CONVERSION PROGRAM!
```

## 10.3 比较字符串

### 10.3.1 CMPS指令

```assembly
cmpsb
cmpsw
cmpsl #一次比较双字并移动
```

比较的是ESI与EDI指针指向的地址上的内容。

```assembly
.section .data
value1:
    .ascii "Test"
value2:
    .ascii "Test"
.section .text
.globl _start
_start:
    movl $1, %eax
    leal value1, %esi
    leal value2, %edi
    cld 
    cmpsl
    je equal
    movl $1, %ebx
    int $0x80

equal:
    movl $0, %ebx
    int $0x80


```

### 10.3.2 CMPS和REP一起使用

> REP只会管ecx寄存器是否为0

所以可以用

```assembly
repe
repne
repz
repnz
```

```assembly
.section .data
value1:
    .ascii "I am a boy !"
value2:
    .ascii "I am a girl!"
.section .text
.globl _start
_start:
    movl $1, %eax
    leal value1, %esi
    leal value2, %edi
    movl $12, %ecx
    cld 
    repe cmpsb #等于时重复，跳出表明不等于(ZF=0)
    je equal #等于时跳转(ZF=1)
    movl %ecx, %ebx
    int $0x80

equal:
    movl $0, %ebx
    int $0x80

```

```assembly
zs@zs-virtual-machine:~/Assembly/10/3/2$ echo $?
4
```

ecx从第12个开始判断，第5个时不相等，还剩4个没判断，所以ecx为4。

### 10.3.3 

```assembly
.section .data
string1:
    .ascii "test"
length1:
    .int 4
string2:
    .ascii "boomerang"
length2:
    .int 9

.section .text
.globl _start
_start:
    lea string1, %esi
    lea string2, %edi
    movl length1, %ecx
    movl length2, %eax
    cmpl %ecx, %eax
    ja longer
    xchg %ecx, %eax #swap values in both registers, the ecx get the less number

#if string1'length(ecx) is less
longer:
    cld
    repe cmpsb #EFLAGS寄存器是根据退出时前一个值进行配置的
    je equal #到停时还是相等的
    jg greater
less:
    movl $1, %eax
    movl $255, %ebx
    int $0x80
greater:
    movl $1, %eax
    movl $1, %ebx
    int $0x80
equal:
#有可能是大于，有可能是小于，也有可能是等于
    movl length1, %ecx
    movl length2, %eax
    cmpl %eax, %ecx
    jg greater
    jl less

    movl $1, %eax
    movl $0, %ebx
    int $0x80

```

